* LIB.TXT - Atari 1040ST 68000 Library Routines
* Copyright (C) Graham M Jones 30th August 1990 

* ----------------------------------------------------------------------- *
* general system subroutines
* ----------------------------------------------------------------------- *

* calculate major buffer addresses, relative to the end of the program
calcbufferptrs:
	; set d0 to the next page boundary after the end of program
	move.l #workspace,d0		; end of program
	add.l #$100,d0			; end of program + 1 page
	and.l #$ffffff00,d0		; previous page boudary to d0

	; read the offsets of each buffer to d0, and store the 
	; result address in a buffer pointer
	move.l #Oscreen1,d1		; get offset
	add.l d0,d1			; add start of buffer workspace
	move.l d1,screen1		; save as a pointer
	move.l #Oscreen2,d1
	add.l d0,d1			; etc...
	move.l d1,screen2
	move.l #Omapdata,d1
	add.l d0,d1
	move.l d1,mapdata
	move.l #Ofmapdata,d1
	add.l d0,d1
	move.l d1,fmapdata
	move.l #Otiledata,d1
	add.l d0,d1
	move.l d1,tiledata

	; allocate game workspace buffers
	move.l #Obuffer1,d1
	add.l d0,d1
	move.l d1,buffer1
	move.l #Obuffer2,d1
	add.l d0,d1
	move.l d1,buffer2
	move.l #Obuffer3,d1
	add.l d0,d1
	move.l d1,buffer3

	; signify end of buffer memory
	move.l #Oendbuffers,d1
	add.l d0,d1
	move.l d1,endbuffers
	rts

* ----------------------------------------------------------------------- *

* initialise system variables
initvars:
	move.l #startvars,a0
	move.l #(endvars-startvars)/4,d1
	clr.l d0
	bsr fillblock			; clear all vars

	; initialise a5 as a pointer to the next page boundary 
	; after the end of program
	move.l #endprog,d0		; end of program
	add.l #$100,d0			; end of program + 1 page
	and.l #$ffffff00,d0		; previous page boudary to d0
	move.l d0,a5

	move.b #1,textcol		; default text colour
	move.b #1,graphiccol		; default graphic colour
	move.l screen1,currentLscreen	; current logial screen address
	move.l screen2,currentPscreen	; current pysical screen address
	rts

* ----------------------------------------------------------------------- *

* animate and move all sprites
animatesprites:
	move.l #spriteparameters,a0	; sprite parameter blocks
	move.l #maxsprites-1,d0
animatespriteloop:
	move.l d0,-(sp)
	bsr animatesinglesprite
	add.l #spriteblocklen,a0	; next sprite
	move.l (sp)+,d0
	dbra d0,animatespriteloop
	rts

* ----------------------------------------------------------------------- *

* animate and move single sprite, whose parameter block is passed in a0
animatesinglesprite:
	; get current animation instruction
	clr.l d0
	move.w pcoffset(a0),d0		; get pc offset
	beq doneani			; sprite is dead

	; decrement repeat
	tst.w repeatoffset(a0)
	beq norepeat
	sub.w #1,repeatoffset(a0)
	bne dorepeat
norepeat:
	add.w #4,pcoffset(a0)		; increment pc if no repeat
dorepeat:

	move.l #animations,a1		; start of animation lists
	add.l d0,a1			; a1=ptr to animation list
	move.w (a1),d0			; get next instruction

	; end of animation sequence?
	bne notreturn
	clr.w pcoffset(a0)		; kill next pass
	clr.w repeatoffset(a0)		; kill repeat offset
	clr.w currentimage(a0)		; kill sprite image
	bra doneani
notreturn:

	; repeat instruction?
	cmp.w #Srepeat,d0
	bne notrepeat
	move.w 2(a1),repeatoffset(a0)	; set repeat counter
	bra animatesinglesprite		; execute next command
notrepeat:

	; goto instruction?
	cmp.w #Sgoto,d0
	bne notgoto
	move.w 2(a1),pcoffset(a0)	; new pc
notgoto:

	; new image?
	cmp.w #Simage,d0
	bne notimage
	move.w 2(a1),currentimage(a0)	; set new image
	bra doneani
notimage:

	; move sprite x,y?
	cmp.w #Smove,d0
	bne notmove
	move.b 2(a1),d1			; get x adjustment
	ext.w d1			; convert to 16 bit signed
	move.b 3(a1),d2			; get y adjustment
	ext.w d2			; convert to 16 bit signed
	; about to move x,y by d1,d2
	bsr specialmovesprite		; trap any special cases
	add.w d1,xposoffset(a0)
	add.w d2,yposoffset(a0)
	; set sprite direction
	clr.b diroffset(a0)		; 0 is right
	tst.w d1
	bpl gotmovingdir
	move.b #1,diroffset(a0)		; 1 is right
gotmovingdir:
notmove:
doneani:
	rts

* ----------------------------------------------------------------------- *

* draw all sprites to current logical screen
displaysprites:
	move.l #spriteparameters,a0	; sprite parameter blocks
	move.l #maxsprites-1,d0
drawspriteloop:
	move.l d0,-(sp)
	bsr drawsinglesprite
	add.l #spriteblocklen,a0	; next sprite
	move.l (sp)+,d0
	dbra d0,drawspriteloop
	rts

* ----------------------------------------------------------------------- *

* draw a single sprite whose header is at a0
drawsinglesprite:
	tst.w pcoffset(a0)		; get pc offset
	beq dssret			; sprite is dead
	clr.l d0
	move.w currentimage(a0),d0	; get current image offset
	beq dssret			; sprite is dead
	move.l #sprdata,a2		; start of image data
	add.l d0,a2			; a2=image address
	clr.l d5			; number of lines to skip
	clr.l d6			; number of lines to draw

	; work out screen position of sprite - first the y position
	move.w yposoffset(a0),d0	; get y pos
	sub.w Wwindowy,d0		; subtract window y pos
	; clip the sprite vertically
	bpl ynotofftop
	; top of sprite is above screen
	move.w depthoffset(a0),d6
	move.w d6,d5
	add.w d0,d6			; d6=bottom of sprite
	bmi dssret			; completely off top of screen
	; d6=number of lines to draw -1
	sub.w d6,d5
	; d5=number of lines to skip (those above the screen)
	clr.w d0			; y is now zero
	bra yhasbeenclipped
ynotofftop:
	cmp.w #windowdepth*16,d0
	bge dssret			; completely off bottom
	move.w depthoffset(a0),d5
	move.w d5,d6
	add.w d0,d5			; d6=bottom of sprite
	sub.w #windowdepth*16,d5
	blt ynotoffbottom		; not off bottom of screen
	; d5=number of lines off bottom of screen
	sub.w d5,d6
	sub.w #1,d6
	; d6=number of lines to draw -1
ynotoffbottom:
	clr.l d5			; (don't skip any lines from top)
yhasbeenclipped:
	mulu.w #160,d0			; y*screen lines

	; now the x position
	clr.l d1
	move.w xposoffset(a0),d1	; get x pos
	sub.w Wwindowx,d1		; subtract window x pos
	ext.l d1			; sign extend d1
	clr.l d7
	move.b d1,d7
	and.b #15,d7			; d7=pixel offset within word
	and.l #$fffffff0,d1			
	asr.l d1			; (x mod 16)/2=screen word position
	add.l d1,d0			; add to start of line
	move.l currentLscreen,a1
	add.l #windowtopmargin+windowleftmargin,a1
	add.l d0,a1			; a1=screen line address
	move.w d1,xstart		; var used for clipping
	move.w #windowwidth*8,d3	; rightmost writeable word

	; is sprite completely off the screen horizontally?
	; also, at this point, we can set up a jump parameter 
	; to use a much faster main loop if there needn't be 
	; any horizontal clipping
	move.l #xisallonscreen,a3
	cmp.w d3,d1			; leftmost pos of sprite
	bge dssret			; is off right of screen
	tst.w d1
	bpl xisallonscreen1
	move.l #xispartoffscreen,a3	; sprite overlaps left of screen
					; or is all off left of screen
xisallonscreen1:
	move.w widthoffset(a0),d0
	lsl.w #3,d0
	add.w d0,d1			; rightmost pos of sprite
	bmi dssret			; is off left screen
	add.w xstart,d0
	cmp.w d3,d0
	bcs xisallonscreen2
	move.l #xispartoffscreen,a3	; sprite overlaps right of screen
xisallonscreen2:

xhasbeenclipped:

* throw the sprite to the screen...
* a0.l=start of sprite parameter block
* a1.l=sprite screen address
* a2.l=sprite image address
* d3.w=rightmost writeable word offset on this line
* d5.l=number of lines to skip
* d6.l=number of lines to draw
* d7.b=pixel position within word (0-15)

	tst.b d5
	beq nolinestoskip
	move.w widthoffset(a0),d0	; get width
	mulu.w d0,d5			; lines to skip*width*16 pixels
	lsl.w d5
	move.l d5,d0
	lsl.w #2,d5
	add.w d0,d5			; lines to skip*width*10 bytes
	add.l d5,a2			; skip image data	
nolinestoskip:

depthloop:
	move.l a1,-(sp)			; save line address
	clr.l d1
	move.w xstart,d4		; count used for clipping
	move.w xstart,d5
	addq.w #8,d5			; count used for clipping
	move.w widthoffset(a0),d1	; d1=width counter
	subq.w #1,d1
widthloop:
	; shift the mask
	clr.l d2
	move.w (a2)+,d2			; get mask word
	not.w d2			; complement it
	swap d2				; move to upper word of d2
	lsr.l d7,d2			; shift right to pixel offset
	not.l d2			; complement it

	; at this point, we can call a much faster routine if we 
	; know that the sprite is completely on the screen horizontally
	jmp (a3)

	; standard sprite main loop, where x may have to be clipped
xispartoffscreen:
	; mask out unwanted screen data
	tst.b d7
	beq maskcurrentword
	cmp.w d3,d5
	bcc maskcurrentword
	and.w d2,8(a1)			; mask right-most word
	and.w d2,10(a1)
	and.w d2,12(a1)
	and.w d2,14(a1)
maskcurrentword:
	cmp.w d3,d4
	bcc dontmaskleft
	swap d2
	and.w d2,(a1)			; mask left-most word
	and.w d2,2(a1)
	and.w d2,4(a1)
	and.w d2,6(a1)
dontmaskleft:

	; mask in the 4 plane words
	moveq.l #3,d0
fourplanewords:
	clr.l d2
	move.w (a2)+,d2			; get plane word
	swap d2				; move to upper word of d2
	lsr.l d7,d2			; shift right to pixel offset
	cmp.w d3,d5
	bcc dontwriteright
	or.w d2,8(a1)			; write right-most screen word
dontwriteright:
	cmp.w d3,d4
	bcc dontwriteleft
	swap d2
	or.w d2,(a1)			; write current screen word
dontwriteleft:
	addq.l #2,a1
	dbra d0,fourplanewords

	addq.w #8,d4			; increment clip counter
	addq.w #8,d5			; increment clip counter
	dbra d1,widthloop
	move.l (sp)+,a1			; recover line address
	add.l #160,a1			; move down one line
	dbra d6,depthloop
dssret:
	rts

* ----------------------------------------------------------------------- *

* much faster version of the sprite main loop, which can only be used 
* when no x clipping is required
xisallonscreen:
	; mask out unwanted screen data
	tst.b d7
	beq Fmaskcurrentword
	and.w d2,8(a1)			; mask right-most word
	and.w d2,10(a1)
	and.w d2,12(a1)
	and.w d2,14(a1)
Fmaskcurrentword:
	swap d2
	and.w d2,(a1)			; mask left-most word
	and.w d2,2(a1)
	and.w d2,4(a1)
	and.w d2,6(a1)

	; mask in the 4 plane words
	moveq.l #3,d0
Ffourplanewords:
	clr.l d2
	move.w (a2)+,d2			; get plane word
	swap d2				; move to upper word of d2
	lsr.l d7,d2			; shift right to pixel offset
	or.w d2,8(a1)			; write right-most screen word
	swap d2
	or.w d2,(a1)+			; write current screen word
	dbra d0,Ffourplanewords

	dbra d1,widthloop
	move.l (sp)+,a1			; recover line address
	add.l #160,a1			; move down one line
	dbra d6,depthloop
	rts

* ----------------------------------------------------------------------- *

* draw the current map to logical screen
* on entry, Wwindowx.w,Wwindowy.w=top left x,y of map
* Wmapwidth.l=width of map
* a2=start of map data
drawmaptoscreen:
	clr.l d1
	clr.l d0
	move.w Wwindowy,d0		; map y pos is in pixels
	lsr.w #4,d0			; y/16=row cell
	mulu.w Wmapwidth+2,d0		; *map width=address of row
	move.w Wwindowx,d1		; map y pos is in pixels
	lsr.w #4,d1			; x/16=column cell
	add.l d1,d0			; add column to row address
	lsl.l d0			; word based table
	add.l d0,a2			; add to start of map

	move.l currentLscreen,a0	; start of screen
	add.l #windowtopmargin,a0	; offset for window top margin
	add.l #windowleftmargin,a0	; address of first word in window

	clr.l d5
	move.w Wwindowy,d5
	and.w #15,d5			; d5=lines to skip for top tile
	move.b d5,-(sp)
	move.l d5,d6
	eor.b #15,d6			; d6=total lines to draw
	bsr drawmaprow			; draw top tile

	; loop to draw middle tiles
	clr.b d5
	move.b #15,d6			; draw full 16 lines
	moveq.l #windowdepth-2,d4	; tiles deep-2
dmcloop:
	bsr drawmaprow			; fetch tile and draw it
	dbra d4,dmcloop

	; lines skipped on top tile = lines to draw on bottom tile
	move.b (sp)+,d6
	sub.l #1,d6
	bcs nolinesskipped
	bsr drawmaprow			; draw bottom tile
nolinesskipped:
	rts

* ----------------------------------------------------------------------- *

* draw a horizontal row of the map, to screen a0, using map data a2
* on exit, a2=a2+Wmapwidth.l*2, a0=a0+2560
drawmaprow:
	tst.b superimpose
	bne maskonmaprow		; superimpose map row

	move.l a0,-(sp)
	move.l a2,-(sp)

	move.l #windowwidth-1,d3	; tiles along screen
	move.l #draw4planewords,a3

	; if the window x pos is mid-way between tiles, then 
	; draw the map at an offset of -8 pixels
	btst.b #3,Wwindowx+1
	beq windowxiseven
	; drawing on a -8 pixel boundary, don't display left 8 
	; pixels of first column
	move.l #draw4planewordsOR,a3
	bsr drawmaptile			; draw a tile
	move.l #draw4planewordsO,a3
	sub.l #8,a0			; screen word to the left
	move.l #windowwidth-2,d3	; tiles along screen-1
windowxiseven:

	; loop to draw middle tiles across
dmrloop:
	bsr drawmaptile			; draw a tile
	dbra d3,dmrloop

	; if we've drawn the map at an offset of -8 pixels, then 
	; fill vacant gap at the right edge of the window
	btst.b #3,Wwindowx+1
	beq windowxiseven1
	move.l #draw4planewordsOL,a3
	add.l #1,a0			; screen byte to the right
	bsr drawmaptile			; draw a tile
windowxiseven1:

	move.l (sp)+,a2
	move.l (sp)+,a0
	move.l d6,d0
	addq.l #1,d0
	mulu.w #160,d0
	add.l d0,a0			; add number of lines printed
	add.l Wmapwidth,a2
	add.l Wmapwidth,a2
	rts

* ----------------------------------------------------------------------- *

* Draw map tile in map list a2 to screen address a0
* with data supplied at address a1
* On entry, a3 contains either of the routines:
*  draw4planewords  - draw on normal word boundaries
*  draw4planewordsO - draw on an 8 pixel offset, overlapping words
* d5=lines to skip for top tile
* d6=total lines to draw
* on exit, a2=a2+2, a0=a0+8
drawmaptile:
	move.l a0,-(sp)
	clr.l d0
	move.w (a2)+,d0			; get tile number
	and.w #$0fff,d0			; prevent tile overflow
	asl.w #7,d0			; mult 128 to get tile data
	move.l tiledata,a1		; start of tile data
	add.l d0,a1			; add offset for current tile
	move.l d5,d1
	asl.w #3,d1			; 8 bytes per tile line
	add.l d1,a1			; skip any tile lines
	move.l d6,d1			; lines to draw
dbloop:
	; draw 4 planes of 16 pixels
	jsr (a3)
	add.l #152,a0
	dbra d1,dbloop			; next screen line
	move.l (sp)+,a0
	add.l #8,a0
	rts

* draw 4 plane words from a1 to screen a0, on an even word bundary
* on exit, a0=a0+8, a1=a1+4
draw4planewords:
	move.w (a1)+,(a0)+
	move.w (a1)+,(a0)+
	move.w (a1)+,(a0)+
	move.w (a1)+,(a0)+

* special code to speed-regulate the main routines to draw 4 plane words
	move.b (sp),(sp)
	move.b (sp),(sp)
	move.b (sp),(sp)
	move.b (sp),(sp)
	rts

* draw 4 plane words from a1 to screen a0, offset by -8 pixels
* on exit, a0=a0+8, a1=a1+8
draw4planewordsO:
	move.b (a1)+,1(a0)
	move.b (a1)+,8(a0)
	move.b (a1)+,3(a0)
	move.b (a1)+,10(a0)
	move.b (a1)+,5(a0)
	move.b (a1)+,12(a0)
	move.b (a1)+,7(a0)
	move.b (a1)+,14(a0)
	addq.l #8,a0
	rts

* draw the right hand bytes of 4 plane words from tile data in a1 to the 
* left hand screen byte a0
* on exit, a0=a0+8, a1=a1+8
draw4planewordsOR:
	move.b 1(a1),(a0)+		; copy byte
	move.b 3(a1),1(a0)		; copy byte
	move.b 5(a1),3(a0)		; copy byte
	move.b 7(a1),5(a0)		; copy byte
	addq.l #7,a0
	addq.l #8,a1
	rts

* draw the left hand bytes of 4 plane words from tile data in a1 to the 
* right hand screen byte a0
* on exit, a0=a0+8, a1=a1+8
draw4planewordsOL:
	move.b (a1)+,(a0)+		; copy byte
	move.b 1(a1),1(a0)		; copy byte
	move.b 3(a1),3(a0)		; copy byte
	move.b 5(a1),5(a0)		; copy byte
	addq.l #7,a0
	addq.l #7,a1
	rts

* ----------------------------------------------------------------------- *

* superimpose a horizontal row of the map, to screen a0, using map data a2
* on even word boundaries
* on exit, a2=a2+Wmapwidth*2, a0=a0+2560
maskonmaprow:
	move.l a0,-(sp)
	move.l a2,-(sp)
	move.l #windowwidth-1,d3	; tiles along screen
	; loop to draw middle tiles across
Mdmrloop:
	bsr maskmaptile			; mask on a map tile
	dbra d3,Mdmrloop
	move.l (sp)+,a2
	move.l (sp)+,a0
	move.l d6,d0
	addq.l #1,d0
	mulu.w #160,d0
	add.l d0,a0			; add number of lines printed
	add.l Wmapwidth,a2
	add.l Wmapwidth,a2
	rts

* ----------------------------------------------------------------------- *

* Superimpose a map tile in map list a2 to screen address a0
* with data supplied at address a1 on even word boundaries
* On entry, d5=lines to skip for top tile
* d6=total lines to draw
* on exit, a2=a2+2, a0=a0+8
maskmaptile:
	clr.l d0
	move.w (a2)+,d0			; get tile number
	and.w #$0fff,d0			; prevent tile overflow
	beq emptytile			; invisible tile
	move.l a0,-(sp)
	mulu.w #128,d0			; mult 160 to get tile data
	move.l tiledata,a1		; start of tile data
	add.l d0,a1			; add offset for current tile
	move.l d5,d1
	asl.w #3,d1			; 8 bytes per tile line
	add.l d1,a1			; skip any tile lines
	move.l d6,d1			; lines to draw
Mdbloop:
	; work out mask in d7
	move.w (a1),d7
	or.w 2(a1),d7
	or.w 4(a1),d7
	or.w 6(a1),d7
	not.w d7			; negate mask

	; draw 4 planes of 16 pixels
	move.w (a1)+,d0			; fetch plane word
	and.w d7,(a0)			; mask out screen
	or.w d0,(a0)+			; mask in plane word
	move.w (a1)+,d0
	and.w d7,(a0)
	or.w d0,(a0)+
	move.w (a1)+,d0
	and.w d7,(a0)
	or.w d0,(a0)+
	move.w (a1)+,d0
	and.w d7,(a0)
	or.w d0,(a0)+
	add.l #152,a0
	dbra d1,Mdbloop			; next screen line
	move.l (sp)+,a0
emptytile:
	add.l #8,a0
	rts

* ----------------------------------------------------------------------- *

* plot a pixel at d0.w=pixel x, d1.w=pixel y, graphiccol=colour
plotpix:
	and.l #$ffff,d1			; clear upper word
	move.w d0,d2			; save xpos
	and.l #$fff0,d0			; x in steps of 16 pixels
	lsr.w d0			; d0=addr of first plane word
	and.w #15,d2			; d2=pixel within plane word
	mulu.w #160,d1			; d1=address of y line
	add.w d1,d0			; d0=offset address from screen
	move.l currentLscreen,a0	; a0=start of screen
	add.l d0,a0			; add offset address

	; work out pixel plane & mask
	move.w #$8000,d0		; pixel to plot
	move.w #$7fff,d1		; plane mask
	lsr.w d2,d0			; shift pixel
	ror.w d2,d1			; shift mask

	; mask pixel in all 4 plane words
	move.b fatpixels,d2		; pixel depth
dofatpixels:
	and.w d1,(a0)			; mask screen plane 1
	btst.b #0,graphiccol
	beq nopix1
	or.w d0,(a0)			; mask in pixel
nopix1:
	addq.l #2,a0
	and.w d1,(a0)			; mask screen plane 2
	btst.b #1,graphiccol
	beq nopix2
	or.w d0,(a0)			; mask in pixel
nopix2:
	addq.l #2,a0
	and.w d1,(a0)			; mask screen plane 3
	btst.b #2,graphiccol
	beq nopix3
	or.w d0,(a0)			; mask in pixel
nopix3:
	addq.l #2,a0
	and.w d1,(a0)			; mask screen plane 4
	btst.b #3,graphiccol
	beq nopix4
	or.w d0,(a0)			; mask in pixel
nopix4:
	add.l #154,a0
	dbra d2,dofatpixels
	rts

* ----------------------------------------------------------------------- *

* initialise screen etc.
initialise:
	clr.l -(sp)
	move.w #32,-(sp)
	trap #1				; set supervisor mode
	addq.l #6,sp
	move.l d0,savestack
	; save screen res & addresses
	move.w #4,-(sp)
	trap #14
	addq.l #2,sp
	move.w d0,oldres		; save res
	move.w #2,-(sp)
	trap #14
	addq.l #2,sp
	move.l d0,oldpscreen		; save physical screen addr
	move.w #3,-(sp)
	trap #14
	addq.l #2,sp
	move.l d0,oldlscreen		; save logical screen addr
	bsr cls
	clr.w d0			; set lo-res
	move.l currentLscreen,a0	; set L screen address
	move.l currentPscreen,a1	; set P screen address
	bsr setscreen
	move.l #palette,a0
	bsr setpalette			; set palette
	bsr initjoystick
	rts

* ----------------------------------------------------------------------- *

* shut the system down and return to gem
closedown:
	bsr disablejoystick
	move.w oldres,d0			; restore old screen
	move.l oldpscreen,a0
	move.l oldlscreen,a1
	bsr setscreen1
	move.l savestack,-(sp)
	move.w #32,-(sp)
	trap #1				; set user mode
	addq.l #6,sp
returntogem:
	clr.w -(sp)
	trap #1

* ----------------------------------------------------------------------- *

* swap logical (hidded) & physical (displayed) screens
swapscreens:
	addq.b #1,gamelooptimer		; increment game timer
	move.w #-1,d0
	move.l currentLscreen,a0
	move.l currentPscreen,a1
	; fall through...

* set screen to resulution d0, logical address in a0, physical 
* address in a1
setscreen:
	move.l a0,currentPscreen	; store P screen address
	move.l a1,currentLscreen	; store L screen address
setscreen1:
	move.w d0,-(sp)
	move.l a0,-(sp)
	move.l a1,-(sp)
	move.w #5,-(sp)
	trap #14
	add.l #12,sp
	rts

* ----------------------------------------------------------------------- *

* set palette to palette table at a0
setpalette:
	move.l a0,-(sp)
	move.w #6,-(sp)
	trap #14
	addq.l #6,sp
	rts

* ----------------------------------------------------------------------- *

* wait for next vblank
* all registers preserved
flyback:
	movem.l a0-a6/d0-d7,-(sp)
	move.w #$25,-(sp)
	trap #14
	addq.l #2,sp
	movem.l (sp)+,a0-a6/d0-d7
	rts

* ----------------------------------------------------------------------- *
* keyboard and joystick routines
* ----------------------------------------------------------------------- *

* scan the keyboard, returning ascii value in d0.b, or zero if 
* no key pressed
keyscan:
	move.w #$b,-(sp)
	trap #1
	addq.l #2,sp	
	tst.l d0
	bmi keywaiting			; key waiting
	clr.l d0			; no key waiting
	rts

keywaiting:
	move.w #7,-(sp)
	trap #1
	addq.l #2,sp
	rts

* Intercept joystick vector to our routine
InitJoystick
	; get address of vector table in d0.l
	move.w #34,-(sp)
	trap #14
	addq.l #2,sp

	; save current joystick table
	move.l d0,a0
	move.l #VectorSaveTable,a1
	move.w #8,d1			; save 8 longs
SaveTable:
	move.l (a0)+,(a1)+
	dbra d1,SaveTable

	; change joystick vector to be intercepted by our routine
	move.l d0,a1
	add.l #24,a1
	move.l #JoystickHandler,a0
	move.l a0,(a1)

	move.l #KBDstring1,-(sp)	; address of string to send
	move.w #1,-(sp)			; length of string to send
	move.w #25,-(sp)		; code for intelligent send
	trap #14
	addq.l #8,sp
	rts

* ----------------------------------------------------------------------- *

* Called every time the keyboard updates the joystick
JoystickHandler:
	movem.l d0-d7/a0-a6,-(sp)
	move.b (a0),d0
	cmp.b #$ff,d0
	bne.s JHEnd
	move.b 2(a0),d0			; get joystick status
	move.b d0,(JoystickStatus)
JHEnd:
	movem.l (sp)+,d0-d7/a0-a6
	rts

* ----------------------------------------------------------------------- *

* Close down joystick handler
DisableJoystick:
	move.l #KBDString2,-(sp)	; address of string to send
	move.w #1,-(sp)			; length of string to send
	move.w #25,-(sp)		; code for intelligent send
	trap #14
	 addq.l #8,sp

	; get address of vector table in d0.l
	move.w #34,-(sp)
	trap #14
	addq.l #2,sp

	; restore vectors for operating system
	move.l d0,a0
	move.l #VectorSaveTable,a1
	move.w #8,d1			; save 8 longs
VectorSaveLoop:
	move.l (a1)+,(a0)+
	dbra d1,VectorSaveLoop
	rts

* ----------------------------------------------------------------------- *

* wait for a keypress, returning ascii value in d0.b
waitkey:
	move.w #7,-(sp)
	trap #1				; wait keypress
	addq.l #2,sp
	rts

* ----------------------------------------------------------------------- *

* clear the both screens
cls:
	clr.w cursorx			; zero cursor x,y
	bsr cls1
	bsr swapscreens
	; fall through...

cls1:
	move.l currentLscreen,a0	; start of screen
	move.l #screenlongwords-1,d1	; size of screen
	clr.l d0			; blank plane data
	; fall through...

* ----------------------------------------------------------------------- *

* fill tile starting between a0 and a0+(d1*4) with d0
fillblock:
	move.l d0,(a0)+
	dbra d1,fillblock
	rts

* ----------------------------------------------------------------------- *

* load map data
* On exit, d0 is -ve if errors occured
loadmapdata:
	; load tile data
	move.l #filename1,d1
	move.l tiledata,d2
	move.l #sizetiles,d3
	bsr open
	bmi loadmaperr
	bsr read
	bmi loadmaperr
	bsr close
	bmi loadmaperr

	; load main map
	move.l #filename2,d1
	move.l mapdata,d2
	move.l #mapwidth*mapdepth*2,d3
	bsr open
	bmi loadmaperr
	bsr read
	bmi loadmaperr
	bsr close
	bmi loadmaperr

	; load foreground map
	move.l #filename3,d1
	move.l fmapdata,d2
	move.l #fmapwidth*fmapdepth*2,d3
	bsr open
	bmi loadmaperr
	bsr read
	bmi loadmaperr
	bsr close
loadmaperr:
	rts

* ----------------------------------------------------------------------- *

* load title screen & set palette
loadtitle:
	move.l #filename4,d1
	move.l currentLscreen,d2
	move.l #128,d3			; skip header
	bsr open
	bsr read

	; copy palette
	move.l currentLscreen,a0
	addq.l #4,a0			; offset to palette data
	move.l #palette,a1		; palette buffer
	move.w #7,d0			; copy 8 longwords
copypalette:
	move.l (a0)+,(a1)+
	dbra d0,copypalette

	move.l #filename4,d1
	move.l currentLscreen,d2
	move.l #32000,d3		; load screen
	bsr read
	bsr close

	move.l #palette,a0
	bsr setpalette			; set palette
	bra swapscreens			; display screen

* ----------------------------------------------------------------------- *
* disk access routines
* ----------------------------------------------------------------------- *

* On entry, d1=address of filename
* d2=where to load it
* d3=filelen
* On exit, d0 is -ve if errors occured

open:	move.w #2,-(sp)
	move.l d1,-(sp)
	move.w #$3d,-(sp)
	trap #1
	addq.l #8,sp
	tst.w d0
	move d0,handle
	rts

create:	clr.w -(sp)
	move.l d1,-(sp)
	move.w #$3c,-(sp)
	trap #1
	addq.l #8,sp
	tst.w d0
	move d0,handle
	rts

read:	move.l d2,-(sp)
	move.l d3,-(sp)
	move.w handle,-(sp)
	move.w #$3f,-(sp)
	trap #1
	add.l #12,sp
	tst.l d0 
	rts

write:	move.l d2,-(sp)
	move.l d3,-(sp)
	move.w handle,-(sp)
	move.w #$40,-(sp)
	trap #1
	add.l #12,sp
	tst.l d0 
	rts

close:	move.w handle,-(sp)
	move.w #$3e,-(sp)
	trap #1
	addq.l #4,sp
	rts

* ----------------------------------------------------------------------- *
* printing routines
* ----------------------------------------------------------------------- *

* print decimal value up to 65535 in d0.w
printdec:
	movem.l a0-a6/d0-d7,-(sp)
	and.l #$ffff,d0			; make sure d0's a word value
	clr.b d5			; flag for leading zeros
	move.w #10000,d1		; power count
printdecloop:
	divu d1,d0			; divide number by power
	move.b d0,d4			; d4.w=result of division
	swap d0
	and.l #$ffff,d0			; d0.w=remainder
	add.b #'0',d4			; get ascii digit
	cmp.b #'0',d4
	bne Dnotfirstzero		; leading zero?
	tst.b d5
	bne Dnotfirstzero
	move.b #' ',d4			; replace with space
	bra Dleadingzero
Dnotfirstzero:
	moveq.b #1,d5			; no more leading zeros
Dleadingzero:
	bsr printchard4			; print digit
	divu #10,d1			; decrement power count
	cmp.w #1,d1			; last digit?
	bne Dnotlastdigit
	moveq.b #1,d5			; no more leading zeros
Dnotlastdigit:
	tst.w d1
	bne printdecloop
	movem.l (sp)+,a0-a6/d0-d7
	rts

* ----------------------------------------------------------------------- *

* print 8 digit BCD or HEX value up to $ffffffff in d0.l
printhexbcd:
	movem.l a0-a6/d0-d7,-(sp)
	move.l #$f0000000,d1		; digit mask
	moveq.l #28,d2			; digit bit pos
	clr.b d5			; flag for leading zeros
	moveq.l #7,d7
printdigit:
	move.l d0,d3
	and.l d1,d3			; get digit
	lsr.l d2,d3			; scoll to LSByte
	and.w #15,d3			; mask unwanted data
	move.l #hexdigits,a0
	clr.w d4
	move.b (a0,d3.w),d4		; d4=ascii character
	cmp.b #'0',d4
	bne notfirstzero		; leading zero?
	tst.b d5
	bne notfirstzero
	move.b #' ',d4			; replace with space
	bra leadingzero
notfirstzero:
	moveq.b #1,d5			; no more leading zeros
leadingzero:
	bsr printchard4
	lsr.l #4,d1			; shift digit mask
	subq.l #4,d2			; decrement digit pos
	bne notlastdigit
	moveq.b #1,d5			; no more leading zeros
notlastdigit:
	dbra d7,printdigit
	movem.l (sp)+,a0-a6/d0-d7
	rts

* ----------------------------------------------------------------------- *

* Print a string of characters at a0
printstring:
	movem.l a0-a6/d0-d7,-(sp)
printstringchar:
	move.b (a0)+,d4
	beq endstring			; end of string?
	bsr printchard4
	bra printstringchar
endstring:
	movem.l (sp)+,a0-a6/d0-d7
	rts

* ----------------------------------------------------------------------- *

* print carriage return
printcr:
	move.b #13,d4
	bra printchard4

* print space
printspace:
	move.b #' ',d4
	; fall through...

* print ascii character in d4 at cursorx,cursory using colour textcol
printchard4:
	movem.l a0-a6/d0-d7,-(sp)

	; work out font address of char
	and.l #$ff,d4			; mask out unwanted d4 data
	cmp.b #32,d4			; font starts with space
	bcs controlchar			; special control char
	move.l #font,a1			; start of font
	sub.b #32,d4			; font starts with space
	lsl.w #3,d4			; 8 bytes per char
	add.l d4,a1			; a1=font address

	; work out screen address of char
	clr.l d0
	move.b cursory,d0
	mulu.w #1280,d0			; address of char line
	clr.l d1
	move.b cursorx,d1
	and.b #$fe,d1			; plane no. (every 2 chars)
	lsl.w #2,d1			; cursor x*4 (plane offset)
	add.w d1,d0			; address offset from screen
	move.l currentLscreen,a0
	move.l currentPscreen,a2
	add.l d0,a0			; screen word of char
	add.l d0,a2			; screen word of char
	move.b cursorx,d1
	and.b #$01,d1
	add.l d1,a0			; a0=L screen byte of char
	add.l d1,a2			; a2=P screen byte of char

	; draw 8 char lines to screen
	move.w #7,d0			; number of lines-1
drawcharline:
	move.b (a1)+,d1			; get char line bits

	; draw 4 plane bytes per char line
	move.w #3,d3			; number of plane bytes-1
	clr.b d4			; colour bit
draw4planebytes:
	btst.b d4,textcol
	beq noplanecol			; no colour bit on this plane
	move.b d1,(a0)			; mask in char line
	move.b d1,(a2)			; mask in char line
noplanecol:
	addq.l #2,a0			; next plane byte
	addq.l #2,a2			; next plane byte
	addq.b #1,d4			; next colour bit
	dbra d3,draw4planebytes

	add.l #152,a0			; next screen line
	add.l #152,a2			; next screen line
	dbra d0,drawcharline

	add.b #1,cursorx
	cmp.b #40,cursorx
	bge docr			; end of line

pcd4ret:
	movem.l (sp)+,a0-a6/d0-d7
	rts

	; d4 was a control character
controlchar:
	cmp.b #13,d4			; carriage return?
	beq docr
	cmp.b #8,d4			; backspace?
	beq backspace
	bra pcd4ret

	; handle carriage return
docr:
	clr.b cursorx
	add.b #1,cursory		; next line
	cmp.b #25,cursory
	blt pcd4ret			; still on screen
	clr.b cursory			; off screen - go back to top line
	bra pcd4ret

	; handle backspace
backspace:
	tst.b cursorx
	beq pcd4ret			; at start of line
	sub.b #1,cursorx		; back 1 char
	bra pcd4ret

* ----------------------------------------------------------------------- *

* input a text line from the keyboard to inputbuffer
* on exit, d1=0 if null string
inputstring:
	move.l #inputbuffer,a0
	moveq.w #39,d0
clearinput:
	move.b #32,(a0)+		; clear input buffer
	dbra d0,clearinput
	clr.w d1			; cursor pos
getinputchar:
	move.w d1,-(sp)
	bsr waitkey			; wait keypress
	move.w (sp)+,d1
	cmp.b #13,d0
	beq doneinput			; CR to confirm
	cmp.b #8,d0
	bne notdel			; DELETE?
	tst.w d1
	beq notdel			; start of line
	subq.w #1,d1			; move cursor back
	move.b d0,d4
	bsr printchard4
	move.b #32,d4			; replace with space
	bsr printchard4
	move.b #8,d4
	bsr printchard4
	moveq.w #32,d0			; clear buffer byte
	move.l #inputbuffer,a0
	move.b d0,(a0,d1.w)
	bra getinputchar
notdel:
	cmp.w #32,d0
	blt getinputchar		; illegal char
	cmp.w #39,d1
	bgt getinputchar		; end of line
	move.l #inputbuffer,a0
	move.b d0,(a0,d1.w)		; store char
	addq.w #1,d1			; move cursor on
	move.b d0,d4
	bsr printchard4			; prnt char d4
	bra getinputchar
doneinput:
	move.l #inputbuffer,a0
	move.b #0,(a0,d1.w)		; terminator=0
	rts

* ----------------------------------------------------------------------- *
* general constants
* ----------------------------------------------------------------------- *

screenlongwords equ $1f40 ; (32000 bytes/4=8000 longwords)

* Joystick status bits
UpBit equ 0
DownBit equ 1
LeftBit equ 2
RightBit equ 3
FireButton equ 7

* ----------------------------------------------------------------------- *
* data
* ----------------------------------------------------------------------- *

KBDString1:
	dc.b $14 ; set joystick event reporting
	even

KBDString2:
	dc.b $1a ; joystick off
	dc.b $08 ; relative mode for mouse
	dc.b 0
	even

hexdigits:
	dc.b "0123456789ABCDEF"
	even

inputbuffer:
	ds.b 40					; text line input
	even

	*     0123456789012345678901234567890123456789
diskerror:
	dc.b 10,13
	dc.b "File access error",10,13
	dc.b 0
	even

filename1:
	dc.b "tiledata.dat",0			; tile graphic data
	even

filename2:
	dc.b "mapdata.dat",0			; main map
	even

filename3:
	dc.b "fmapdata.dat",0			; foreground map
	even

filename4:
	dc.b "title.neo",0			; title screen
	even

palette:
	dc.w $000,$700,$070,$007
	dc.w $777,$000,$000,$000
	dc.w $000,$000,$000,$000
	dc.w $000,$000,$000,$000

* ----------------------------------------------------------------------- *
* variables
* ----------------------------------------------------------------------- *

savestack:
	ds.l 1 ; save supervisor stack
oldres:
	ds.w 1 ; save res
oldpscreen:
	ds.l 1 ; save physical screen address
oldlscreen:
	ds.l 1 ; save logical screen address

* buffer addresses, calculated once the program has been 
* located in memory (see their counterparts in SYSCONST.TXT)
screen1:	ds.l 1 ; screen 1
screen2:	ds.l 1 ; screen 2
mapdata:	ds.l 1 ; main map data
fmapdata:	ds.l 1 ; foreground map data
tiledata:	ds.l 1 ; tile graphics data
buffer1:	ds.l 1 ; game workspace buffer
buffer2:	ds.l 1 ; game workspace buffer
buffer3:	ds.l 1 ; game workspace buffer
endbuffers:	ds.l 1 ; end of buffer workspace

startvars equ * ; start of CLEAR area

handle:
	ds.w 1 ; disk access handle
closedownflag:
	ds.w 1 ; set when closedown requested
currentLscreen:
	dc.l 0 ; current logial screen address
currentPscreen:
	dc.l 0 ; current physical screen address
windowx:
	ds.w 1 ; current map window x position in pixels
windowy:
	ds.w 1 ; current map window y position in pixels
Wwindowx:
	ds.w 1 ; workspace window x
Wwindowy:
	ds.w 1 ; workspace window y
Wmapwidth:
	ds.l 1 ; workspace window width
superimpose:
	ds.w 1 ; set if map is to be superimposed onto screen
spritex:
	ds.w 1 ; workspace used in sprite collision code
spritey:
	ds.w 1 ; workspace used in sprite collision code
intendedspritex:
	ds.w 1 ; workspace used in sprite collision code
intendedspritey:
	ds.w 1 ; workspace used in sprite collision code
xstart:
	ds.w 1 ; var used for clipping in sprite routine
VectorSaveTable:
	ds.b 40 ; used to save kbd processor jump table
cursorx:
	ds.b 1 ; text cursor x pos (must be on even)
cursory:
	ds.b 1 ; text cursor y pos
Joystickstatus:
	ds.b 1 ; joystick status
textcol:
	ds.b 1 ; text colour
graphiccol:
	ds.b 1 ; graphic colour
fatpixels:
	ds.b 1 ; set to 1 for double-size pixels
gamelooptimer:
	ds.b 1 ; game loop iterations
 even

endvars equ * ; end of CLEAR area
	ds.l 1 ; padding to allow for uneven longword length of var list

* ----------------------------------------------------------------------- *
