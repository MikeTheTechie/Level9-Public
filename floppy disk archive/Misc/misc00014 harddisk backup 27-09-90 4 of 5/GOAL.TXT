; Goal.TXT Copyright (C) 1989 Level 9 Computing.
;
; for Floor Map Editor.
;
; N.W.Austin 28/6/89
;
;-----

;The FLOOR.DAT floor map is compressed; obstacles are marked
;as 1 bit on a fine grid 4-pixels apart; Info for corrective
;action (avoidance pointer) is stored as 4 bits on a 'coarse
;grid 8 pixels apart. Height of the 'floor' (e.g. depth of a
;river) is 4 bits on a coarse grid 8 pixels apart.

;Thus there are 4 points on the fine grid for every point on
;the coarse grid (the four points are a square, NOT linear)

;'Blocked' points do not need a height; 'Unblockd' do not need
;an avoidance pointer. To compress, where not all of each group
;of 4 points (on the fine grid) are 'blocked' the height is
;assumed to that of surrounding squares; thus only 8 bits stores
;the height, avoidance and blocked info for each coarse point.

;The header (NOT IMPLEMENTED) stores the ObjectNumber, Margin
;X/Z, Width and Height so that walls need not be stored.
;Typically for each room about 446 bytes are stored (100 rooms
;44K bytes)

;-----

var
; used to prevent sliding when avoiding a door
 HitExit
 OriginalHitExit

const
 ACBspOffset=2

; constants related to SearchTime
 CantBePushed=30 ; can't be pushed if not got any nearer in N steps
 ReleaseFromPerson=40 ; ignore people collisions if stuck on a 
; person for N steps
 ReduceAccuracy=100 ; force coarse accuracy after N steps
 ReduceAccuracyPlus1=101
; GMJ 10jul90 DoRetreat=125 ; retreat after N moves
 AvoidCollisions=100 ; 150 ; GMJ 10jul90 - avoid ALL collisions

begin

; If ACBList(dx4) setup by AAInitGD takes ACB one step
; further to destination. If not setup then does nothing.
; ACBList+ACBstatus(dx4) is return code, if not 254 then
; ACB GD has ended
;
.GDinProgress
 gosub @GDinProgress1
;
; Are we getting any closer?
 x1=DestX
 sub x1,GoalNowX
 if x1<32000 then gotabsxdist
 x2=x1
 x1=0
 sub x1,x2
.gotabsxdist ; x1 is abs x distance
 x3=DestZ
 sub x3,GoalNowZ
 if x3<32000 then gotabszdist
 x4=x3
 x3=0
 sub x3,x4
.gotabsZdist ; x3 is abs z distance
 add x1,x3 ; x1 is combined distance (no diagonals allowed)
;
 asr x1
 asr x1
 asr x1
 asr x1 ; distance in steps of 16 pixels
;
 x2=ACBPreviousDistance
 add x2,ACBHeader
 &x3=ACBList(x2) ; x3 is previous distance
 if x1>x3 then notgettingthere
 if x1=x3 then notgettingthere
 &ACBList(x2)=x1 ; reset distance if getting closer
.notgettingthere
 x2=ACBSearchTime
 add x2,ACBHeader ; point x2 to 'stuck' timer
 x4=0
 if x1<x3 then weregettingthere ; getting nearer - zero 'stuck' timer
;
; we're not getting any nearer...
 &x4=ACBList(x2)
 add x4,c1 ; ...so increment 'stuck' timer
;
.weregettingthere
 &ACBList(x2)=x4
.awgcret
 return

;-----

.GDinProgress1
 Running=false
 &v1=ACBList(dx4) ;get animation sequence
 dir=1
 if v1=2701 then @GIPwalk
 if v1=3231 then @GIPwalk
 if v1=3051 then @GIPrun
 dir=3
 if v1=2703 then GIPwalk
 if v1=3233 then @GIPwalk
 if v1=3053 then GIPrun
 dir=5
 if v1=2705 then GIPwalk
 if v1=3235 then @GIPwalk
 if v1=3055 then GIPrun
 dir=7
 if v1=2707 then GIPwalk
 if v1=3237 then @GIPwalk
 if v1=3057 then GIPrun
 dir=0
 goto GIPwalk
.GIPrun
 Running=false ; stop running when we change direction 06/02/90 ; true
.GIPwalk

 v1=ACBintendedDirection
 add v1,dx4
 IntendedDir=ACBList(v1)

 v1=ACBdestX
 add v1,dx4
 &DestX=ACBList(v1)

 v1=ACBdestZ
 add v1,dx4
 &DestZ=ACBList(v1)

 v1=ACBxOffset
 add v1,dx4
 &GoalNowX=ACBList(v1)

 v1=ACBzOffset
 add v1,dx4
 &GoalNowZ=ACBList(v1)

 x1=ACBstatus
 add x1,dx4
 x1=ACBList(x1)
 x2=32
 if x1=ACBFindNpc then destisnotdoor ; very coarse accuracy if dest=person
 x2=16
 if x1=ACBPushedAway then destisnotdoor ; coarse accuracy if being pushed 
 if x1=ACBGoDoor then destisnotdoor ; or on a 'go door' command
 x2=4 ; fine accuracy if dest is e.g. a chair
 if x1>15 then destisnotdoor
 x2=8 ; medium accuracy if dest is a door
.destisnotdoor
;
; Can we make the move even more coarse?
 if actor=user then gdnotfindcoarse ; player must use default accuracy
push x2
 gosub @SetActorAttributes
 gosub @GetCurrentCommand
pop x2
; If we haven't got any closer to our dest in quite a while (but not 
; long enough to do a retreat), then cut down on the accuracy of the move
;
 if room<50 then LocalMovesCoarse ; GMJ 10jul90
; INDOOR localmoves MUST be accurate, since we may want someone 
; to sit on a chair that isn't listed as an object (dining room). 
; OUTDOOR localmoves don't matter
;
 if verb=iLocalMove then CantForceCoarse
;
.LocalMovesCoarse ; GMJ 10jul90
;
 x1=ACBSearchTime
 add x1,ACBHeader
 &x3=ACBList(x1)
 if x3>ReduceAccuracy then ForceCoarse
.CantForceCoarse
; Allow another +/- 16 pixels accuracy if the current 
; find command contains a special preposition...
 if prep<>findcoarse then gdnotfindcoarse
.ForceCoarse
 add x2,c16 ; GMJ 10jul90 ; c32
.gdnotfindcoarse
;
 x1=DestX
 sub x1,x2 ; width of X precision
 if GoalNowX<x1 then @GSS1 ; too far to left.
 add x1,x2
 add x1,x2
 if GoalNowX>x1 then @GSS1 ; too far to right.
 asr x2 ; z precision is x precision / 2
 x1=DestZ
 sub x1,x2 ; width of Z precision
 if GoalNowZ<x1 then @GSS1 ; too far north.
 add x1,x2
 add x1,x2
 if GoalNowZ>x1 then @GSS1 ; too far south.

;-----

;reached destination
.GDHaveArrived
 v1=ACBstatus
 add v1,dx4
;
; Don't set 'arrived' flag if we've only been pushed out of 
; someone's way on a temporary GD path
 v3=ACBList(v1)
 v2=0
 if v3=ACBPushedAway then GdTempArrived
 v2=253 ;Arrived
.GdTempArrived
 ACBList(v1)=v2
; Don't stop if it's an E/W door
 if v3=1 then StopAtDoor
 if v3=5 then StopAtDoor
 if v3=14 then StopAtDoor
 if v3=15 then StopAtDoor
 if v3<16 then @GSSStop
.StopAtDoor
;
.GDstandStill
.GDSSarr
 if dir=0 then GSSStop
 gosub @GetStandingAniDv1
 add dv1,dir
 dv2=GoalNowX
 dv3=GoalNowZ
 x1=ACBHOffset
 add x1,ACBHeader
 &dv4=ACBList(x1)
 gosub @RepositionDv1234vec ; reposition person at correct vacant pos
.GSSstop
 goto @GDstoreACB

;-----

.GSS1
; First, a failsafe to allow us to get out of complex shapes 
; if we haven't got any closer to our dest in ages.
; Such a shape might be: 
;
;			   ______
;			     	|
;			|     	|
;			|      C|
;			---------
;
;					X
;
; Where C is current pos, and X is dest.
;

; GMJ 10jul90
; Disable retreat in favour of AvoidCollisions, which was never 
; called, since the retreat code reset the timer to prevent 
; repeating the retreat

; x1=ACBSearchTime
; add x1,ACBHeader
; &x3=ACBList(x1)
; if x3<DoRetreat then GSS1NotTrapped
; &ACBList(x1)=c0 ; reset timer
;;
;; if stuck when being pushed, then treat as arrived
; x1=ACBStatus
; add x1,ACBHeader
; x1=ACBList(x1)
; if x1=ACBPushedAway then @GdHaveArrived
;;
;; To get out of the shape, try going in the opposite direction to 
;; our dest (set new dest to opposite corner of screen)...
; x1=4 ; left of screen
; if destx>goalnowx then gotreversedestx
; x1=288 ; right of screen
;.gotreversedestx
; x2=4 ; top of screen
; if destz>goalnowz then gotreversedestz
; x2=196 ; bottom of screen
;.gotreversedestz
; goto @DoPushNpc ; use same routine as being pushed, as it 
;; won't interfere with the main GD move
;.GSS1NotTrapped
;
; IntendedDir is direction we were going in before the
; last collision. Can we go in that direction now?
 if IntendedDir=0 then @GDcantGoIntended
 TryDir=IntendedDir
 gosub @GDtryDirection

 OriginalHitExit=HitExit ;*

 if ReturnCode=999 then @GDStandStill
 if ReturnCode=0 then @GDcantGoIntended
; We can go in IntendedDir at last, but if we can only go one
; square that way, then do a 'slide'...
;
; 29/12/89
 x1=startreversaltable
 add x1,dir
 x1=list5(x1)
 if x1=IntendedDir then @GDAvoidOver ; don't slide backwards
;
 if dir=IntendedDir then @GDAvoidOver ; prevent double slide
 if dir=0 then @GDAvoidOver ; prevent non-diagonal slide 08/11/89
 StartX=GoalNowX
 StartY=GoalNowZ
 gosub @AdvanceTryDir
 gosub @AdvanceTryDir ; test 2 squares ahead
 gosub @GDtryLookAhead
 if ReturnCode<>0 then @GDavoidOver
; Can only go one square in IntendedDir, so do a 'slide' 
; in IntendedDir, and keep moving in the current direction...
;.SlideIntendedDir
 x1=2
 if IntendedDir=5 then SlideIntendedZ ; slide S
 x1=4 ; 22/12/89
 if IntendedDir=3 then SlideIntendedX ; slide E
 x1=65534 ; -2
 if IntendedDir=1 then SlideIntendedZ ; slide N
 x1=65532 ; -4 ; 22/12/89
; slide W
.SlideIntendedX
; Don't slide any more if we're close to the axis
 x2=GoalNowX
 sub x2,DestX
 if x2<5 then GDAvoidOver
 if x2>65533 then GDAvoidOver
 dx2=x1
 return
.SlideIntendedZ
; Don't slide any more if we're close to the axis
 x2=GoalNowZ
 sub x2,DestZ
 if x2<5 then GDAvoidOver
 if x2>65533 then GDAvoidOver
 dx3=x1
 return
;
; Move in intended direction...
.GDavoidOver
 IntendedDir=0
 goto @GDmakeMove
;
.GDCantGoIntended
 gosub @GDcalcFastest ; change current dir?
 gosub @GDtryDirection
 if ReturnCode=999 then @GDStandStill
 if ReturnCode<>0 then @GDmakeMove
 IntendedDir=TryDir ; desired direction
 TryDir=Dir ; keep going in current dir?
 gosub @GDtryDirection
 if ReturnCode=999 then @GDStandStill
 if ReturnCode<>0 then @GDmakeMove
; can't go in current dir OR desired dir...
 TryDir=IntendedDir ; desired direction (from above)
 gosub @GDtryDirection ; get CurrentSquare for avoid routines

 OriginalHitExit=HitExit ;*

 Dir=TryDir
 if dir=1 then @GDavoidEW
 if dir=3 then @GDavoidNS
 if dir=5 then @GDavoidEW
 if dir=7 then @GDavoidNS
 goto @GDStuck ; shouldn't get here!

.GDavoidEW
 gosub @AvoidanceEW ; any specific preference?
 if returncode=999 then @GDStandStill ; hit npc
 if returncode=0 then GDAvoidEW1 ; no specific preference
 if returncode<>1000 then @GDMakeMove ; ok to move
 return ; slide has been set up
.GDAvoidEW1

 gosub @gdIntelLorR
 if TryDir=7 then @GDA1

 v1=32 ;0010 0000 E
 and v1,CurrentSquare
 if v1=0 then GDA1
 TryDir=3
 gosub @GDtryDirection
 if ReturnCode=999 then @GDStandStill
 if ReturnCode=0 then GDA1
 gosub @TestNSafterEW
 if result=false then @GDmakeMove
 return

.GDA1
 v1=16 ;0001 0000 W
 and v1,CurrentSquare
 if v1=0 then GDA2
 TryDir=7
 gosub @GDtryDirection
 if ReturnCode=999 then @GDStandStill
 if ReturnCode=0 then GDA2
 gosub @TestNSafterEW
 if result=false then @GDmakeMove
 return

.GDA2
 v1=32 ;0010 0000 E
 and v1,CurrentSquare
 if v1=0 then GDA3
 TryDir=3
 gosub @GDtryDirection
 if ReturnCode=999 then @GDStandStill
 if ReturnCode=0 then GDA3
 gosub @TestNSafterEW
 if result=false then @GDmakeMove
 return

.GDA3
 goto @GDnoPreference

.GDavoidNS
 gosub @AvoidanceNS ; any specific preference?
 if returncode=999 then @GDStandStill ; hit npc
 if returncode=0 then GDAvoidNS1 ; no specific preference
 if returncode<>1000 then @GDMakeMove ; ok to move
 return ; slide has been set up
.GDAvoidNS1

 gosub @gdIntelUorD
 if TryDir=5 then GDA4

 v1=128 ;1000 0000 N
 and v1,CurrentSquare
 if v1=0 then GDA4
 TryDir=1
 gosub @GDtryDirection
 if ReturnCode=999 then @GDStandStill
 if ReturnCode=0 then GDA4
 gosub @TestEWafterNS
 if result=false then @GDmakeMove
 return

.GDA4
 v1=64 ;0100 0000 S
 and v1,CurrentSquare
 if v1=0 then GDA5
 TryDir=5
 gosub @GDtryDirection
 if ReturnCode=999 then @GDStandStill
 if ReturnCode=0 then GDA5
 gosub @TestEWafterNS
 if result=false then @GDmakeMove
 return

.GDA5
 v1=128 ;1000 0000 N
 and v1,CurrentSquare
 if v1=0 then GDA6
 TryDir=1
 gosub @GDtryDirection
 if ReturnCode=999 then @GDStandStill
 if ReturnCode=0 then GDA6
 gosub @TestEWafterNS
 if result=false then @GDmakeMove
 return
.GDA6

;-----

; No specific floor pointers to help us avoid object...
.GDnoPreference
 if dir=1 then @GNP1
 if dir=5 then @GNP1
;
; Avoid N/S
 gosub @gdIntelUorD
 gosub @GDtryDirection
 if ReturnCode=999 then @GDStandStill
 if ReturnCode=0 then GNP10
 gosub @TestEWafterNS
 if result=false then @GDmakeMove
 return
;
; can't go in desired N/S direction, so try reversed N/S dir...
.GNP10
 x1=startreversaltable
 add x1,trydir
 trydir=list5(x1)
 gosub @GDtryDirection
 if ReturnCode=999 then @GDStandStill
 if ReturnCode=0 then @GNPstuck
 gosub @TestEWafterNS
 if result=false then @GDmakeMove
 return
;
; Avoid E/W
.GNP1
 gosub @gdIntelLorR
 gosub @GDtryDirection
 if ReturnCode=999 then @GDStandStill
 if ReturnCode=0 then GNP20
 gosub @TestNSafterEW
 if result=false then @GDmakeMove
 return
;
; can't go in desired E/W direction, so try reversed E/W dir...
.GNP20
 x1=startreversaltable
 add x1,trydir
 trydir=list5(x1)
 gosub @GDtryDirection
 if ReturnCode=999 then @GDStandStill
 if ReturnCode=0 then GNPstuck
 gosub @TestNSafterEW
 if result=false then @GDmakeMove
 return
;
; We can't avoid at 90 degrees, so try going backwards
.GNPStuck
 x1=startreversaltable
 add x1,dir
 trydir=list5(x1)
 gosub @GDABStryDir ; because GDTryDirection won't allow for 
; a reverse!!!
 if ReturnCode=999 then @GDStandStill
 if ReturnCode<>0 then @GDMakeMove ; go backwards
;
.GDStuck
; Actor has got onto a blocked square, so find the nearest vacant 
; one...
 gosub @GetStandingAniDv1
 add dv1,trydir
 ObjectNumber=dv1
push dv2
push dv3
 x1=dv2
 x2=dv3
push x1
push x2
 collidewithself=true ; make sure we don't stay in same place!
 gosub @FindVacantPositionVEC
 collidewithself=false
pop x2
pop x1
 dx2=dv2
 sub dx2,x1
 dx3=dv3
 sub dx3,x2 ; get adjustments to move to new pos
pop dv3
pop dv2
 x1=ACBStatus
 add x1,ACBHeader
 x1=ACBList(x1) ; x1=status
 if x1=ACBPushedAway then @GDHaveArrived ; stop if being pushed
 return

;-----

; If there is specifically one E or W pointer, then take it...
.AvoidanceEW
 x1=48 ; 0011 0000 EW
 and x1,CurrentSquare
 trydir=3
 if x1=32 then AvoidGotDirection ; 0010 0000 E only
 trydir=7
 if x1=16 then AvoidGotDirection ; 0010 0000 W only
 ReturnCode=0 ; no specific pointer
 return
;
; If there is specifically one N or S pointer, then take it...
.AvoidanceNS
 x1=192 ; 1100 0000 NS
 and x1,CurrentSquare
 trydir=1
 if x1=128 then AvoidGotDirection ; 1000 0000 N only
 trydir=5
 if x1=64 then AvoidGotDirection ; 0100 0000 S only
 ReturnCode=0 ; no specific pointer
 return
;
; We've got one specific pointer, but is there anything in the way?
.AvoidGotDirection
 gosub @GDtryDirection
 if ReturnCode=999 then AvoidRet ; blocked by npc
 if ReturnCode=0 then AvoidRet ; blocked (avoidance pointer error!)
 if trydir=3 then AGDEW
 if trydir=7 then AGDEW
 gosub @TestEWafterNS
 goto AGDtestedSlide
.AGDEW
 gosub TestNSafterEW
.AGDtestedSlide
 if result=false then AvoidRet ; ok to move
 ReturnCode=1000 ; a slide has been set up
.AvoidRet
 return

;-----

.AdjustPersonHeightVec2
 goto @AdjustPersonHeightVec

;-----

; N/S is currently blocked, so we are avoiding by going 
; E/W (trydir). 
;
; TestNSafterEW tests to see if the N/S is blocked AFTER the 
; E/W move, so that we can slide E/W, while still facing N/S.
; This avoids 'zig-zagging' when going e.g. N/W/N/W etc
;
; RESULT=TRUE if the E/W slide is carried out.
;
.TestNSafterEW

;*
; don't slide if we originally hit an exit
 result=false
 if OriginalHitExit=true then TNSAEWRet
;*

 gosub @LookAheadDiagonal ; look ahead diagonally
 result=false
 if ReturnCode=999 then TNSAEWret ; blocked
 if ReturnCode=0 then TNSAEWret ; blocked
 dx2=StartX
 sub dx2,GoalNowX ; get x distance to slide
 result=true ; slide done
;
.TNSAEWret
 return

;-----

.TestEWafterNS

;*
; don't slide if we originally hit an exit
 result=false
 if OriginalHitExit=true then TNSAEWRet
;*

push trydir
 trydir=dir ; swap dir & trydir
pop dir
 gosub @LookAheadDiagonal
 result=false
 if ReturnCode=999 then TEWANSret ; blocked
 if ReturnCode=0 then TEWANSret ; blocked
 dx3=StartY
 sub dx3,GoalNowZ ; get z distance to slide

; 22/12/89
 x1=2
 if dx2<32000 then OKslideS
 x1=65534 ; -2
.OKSlideS
 dx3=x1
; 22/12/89

 result=true ; slide done
;
.TEWANSret
push trydir
 trydir=dir ; swap back dir & trydir
pop dir
 return

;-----

; Look ahead diagonally, using DIR for N/S and TRYDIR for E/W
.LookAheadDiagonal
 returncode=0
 v1=4 ; v1 is the adjustment to look ahead
 if dir=5 then AddNSmove
 if dir<>1 then @TNSAEWret ; dir is not N/S
 v1=65532 ; -4
.AddNSmove
 StartY=GoalNowZ
 add StartY,v1 ; StartY is the new Z pos
;
 v1=4
 if trydir=3 then AddEWmove
 if trydir<>7 then @TNSAEWret ; trydir is not E/W
 v1=65532 ; -4
.AddEWmove
 StartX=GoalNowX
 add StartX,v1 ; StartX is the new X pos
;
 goto @GDtryLookAhead

;-----

.AdvanceTryDir
;Predict where 'TryDir' move will take us...
 if TryDir<>1 then GTD5
 sub StartY,c4
.GTD5
 if TryDir<>3 then GTD6
 add StartX,c4
.GTD6
 if TryDir<>5 then GTD7
 add StartY,c4
.GTD7
 if TryDir<>7 then GTD8
 sub StartX,c4
.GTD8
 return

;-----

.GDtryDirection
 CurrentSquare=0 ; return no preference if we return & do an avoid
 if TryDir=0 then @GTL2

 if dir<>1 then GTD1
 if TryDir=5 then @GTL2
.GTD1
 if dir<>3 then GTD2
 if TryDir=7 then @GTL2
.GTD2
 if dir<>5 then GTD3
 if TryDir=1 then @GTL2
.GTD3
 if dir<>7 then GTD4
 if TryDir=3 then @GTL2
.GTD4

.GDAbsTryDir
 StartX=GoalNowX
 StartY=GoalNowZ
 gosub @AdvanceTryDir

.GDtryLookAhead
; First, make sure we don't go through any doors unless 
; we're supposed to...
 HitExit=False
 ActorX=StartX
 ActorZ=StartY
 v1=ACBStatus
 add v1,ACBHeader
 v2=ACBList(v1)
push v1
push v2 ; save original status
push dv2
push dv3
push dv4
push dx2
push dx3
push dx4
push dir
push graphicsdir
push lastrequesteddirection
 gosub @SASCHeckStartMoveVEC
pop lastrequesteddirection
pop graphicsdir
pop dir
pop dx4
pop dx3
pop dx2
pop dv4
pop dv3
pop dv2
pop v2 ; get original status
pop v1
 ACBList(v1)=v2 ; recover original status
; did we hit a door?
 x1=ACBLeavingDirection
 add x1,ACBHeader
 x2=ACBList(x1) ; get leaving dir (if any)
 if x2=false then @GDNoExitCollision ; didn't hit a door
 x3=127
 and x2,x3 ; we don't want bit 7
;
; Actor has hit a door. Go though it if we wanted this door anyway, 
; or if we're being physically pushed through it...
 if v2=x2 then @GDNoExitCollision
;** REMOVED 22/08/90 - causes problems when Sam pushes someone 
; out of a room while their conversation is being controlled 
; by another npc ** if v2=ACBPushedAway then PushedThroughDoor
push x1
push dir
 dir=x2
 gosub @RealToPhysicalDirVec
 x5=dir
pop dir
pop x1
 if x5<>trydir then @GDNoExitCollision
; can't move in dir of exit
 ACBList(x1)=c0 ; clear leaving-room flag
 if actor<>user then GDNEC2
 wantnewroom=false
.GDNEC2
 HitExit=true
 ReturnCode=0 ; blocked
 return
;
; We're been pushed through a door, so put a command on the 
; stack to make us return to this room
.PushedThroughDoor
 gosub @SetActorAttributes
 verb=igdgo
 prep=0
 noun1=currentpos(actor)
 noun2=nullobject
 gosub @SinglePushFifo
 goto GDNEC1 ; fall through...
;
.GDNoExitCollision
 ACBList(x1)=c0 ; clear leaving-room flag
 if actor<>user then GDNEC1
 wantnewroom=false
.GDNEC1
;
; Avoid all collisions after we've waited a LONG time...
 x1=ACBSearchTime
 add x1,ACBHeader
 &x1=ACBList(x1)
 if x1>AvoidCollisions then @IgnoreCollisions
;
 push CursorX
 push CursorZ
 CursorX=StartX
 CursorZ=StartY
 gosub @GDpointOnMap
 CurrentSquare=48 ;00110000 height=0
 if ReturnCode=0 then GTL1
 gosub @GDreadSquare ;current square=collision byte
 gosub @GDquadMask ;v1=mask
.GTL1
 pop CursorZ
 pop CursorX
 and v1,CurrentSquare
 if v1=0 then GTL3
.GTL2
 ReturnCode=0 ;blocked
 return
.GTL3
;
; Check for collisions with static npcs that can be detoured...
 push dv2
 push dv3
 push dx2
 push dx3
 dv2=StartX
 dv3=StartY
 dx2=0
 dx3=0
 gosub @CPC0vec ; dx1=0 if no npc's in our way
 pop dx3
 pop dx2
 pop dv3
 pop dv2
 if dx1=0 then @NoPeopleCollision ; no npcs in the way
;
; Ignore people collisions if we've been stuck on someone for 
; a long time...
; GMJ 10jul90 .IgnoreCollisions
 x1=ACBSearchTime
 add x1,ACBHeader
 &x1=ACBList(x1)
 if x1<ReleaseFromPerson then NotWaitedLong
; decrement PreviousDistance so that we can walk another 32 pixels 
; without getting 'nearer' to our dest
.IgnoreCollisions ; GMJ 10jul90
 x1=ACBPreviousDistance
 add x1,ACBHeader
 &x2=ACBList(x1)
 sub x2,c2
 if x2<32000 then WaitedLongEnough
 x2=0
.WaitedLongEnough
 &ACBList(x1)=x2
 goto @NoPeopleCollision
;
; Is the npc we've bumped into the one we're trying to find?
.NotWaitedLong
 gosub @IsDx1TargetNpc ; are we trying to find this npc?
 if result=false then HitNpcDx1 ; no - so treat as collision
;
; We've hit the npc we're trying to find...
;.GDTLAArrived
 x1=ACBStatus
 add x1,ACBHeader
 x2=ACBArrived
 ACBList(x1)=x2
 ReturnCode=999 ; special code to prevent further decisions
 return
;
.NoPeopleCollision
 ReturnCode=1
 return
;
; We've bumped into an npc of no importance
.HitNpcDx1
; is he stood on our target
 x1=ACBStatus
 add x1,ACBHeader
 x1=ACBList(x1) ; get our status
 if x1<16 then @DetourNpc ; can't push someone by a door
 x1=dx1
 gosub @IsPersonStoodOnTarget
 if result=false then @DetourNpc ; if not, detour him
;
; if player trying to get to target, then say 'Npc was in way' and halt
 if ACBHeader<>PlayerACB then @HNDNotPlayer
 if executingracetrack<>false then @HNDNotPlayer
 if verb=ifollow then @HNDNotPlayer ; don't stop following someone
 x1=ACBStatus
 add x1,PlayerACB
 x1=ACBList(x1)
 if x1=ACBPushedAway then @HNDNotPlayer ; player being pushed
code -
 message cr
code +
 v1=dx1
 gosub @SetV1Actor ; return v1=object/actor for header v1
 x1=v1
 gosub @printtheobjectx1Vec ; <npc>
code -
 message 2840 ; was in sam's way
 message dot
code +
 x1=ACBStatus
 add x1,PlayerACB
 ACBList(x1)=c0 ; quit GD
 executingcommand=false
 actor=user
 gosub @stop
 ReturnCode=999
 return
;
; Npc dx1 is stood on Actor's target - push him?
.HNDNotPlayer
 x2=ACBHaltDelay
 add x2,dx1
 x2=ACBList(x2)
 if x2<>0 then DetourNpc ; Don't push someone who's frozen
 x2=ACBStatus
 add x2,dx1
 x2=ACBList(x2)
 if x2=ACBPushedAway then DetourNpc ; npc already being pushed
;
; ALWAYS push the player so that we can get to our destination
 if dx1=PlayerACB then PushNpcDx1
;
 &x1=ACBList(dx1)
; don't push npc unless they're standing still
 if x1<StandingAnimation then DetourNpc
 if x1<MaxStandingAnimation then PushNpcDx1
;
; Detour Npc by running
.DetourNpc
 Running=true
 goto @GTL2
;
; Make the npc we've collided with move away from us at a right angle 
; to the direction in which we wish to move...
.PushNpcDx1
push dx4
push ACBHeader
 CursorX=GoalNowX
 CursorZ=GoalNowZ ; preserve our x,z
 ACBHeader=dx1
 dx4=dx1
 x4=ACBXOffset
 add x4,ACBHeader ; x4 points to obstruction x pos
 &GoalNowX=ACBList(x4) ; current obstruction x pos
 add x4,c2
 &GoalNowZ=ACBList(x4) ; current obstruction z pos
 ScanNoTargetNpc=true ; treat target npcs as obstacles
 if trydir=3 then @DontPushNpcX ; we're currently moving along x axis!
 if trydir=7 then @DontPushNpcX ; we're currently moving along x axis!
;
; In which x direction can we move the furthest?
push GoalNowX
 GoalNowX=CursorX ; start scan from our x, not the npc's
push trydir
push destx
 trydir=3
 destx=GoalNowX
 add destx,c32
 add destx,c16
push dx1
 gosub @ScanRoute
pop dx1
;
push result ; false if we could move full distance east
push value ; value is distance we could travel east
 trydir=7
 destx=GoalNowX
 sub destx,c32
 sub destx,c16
push dx1
 gosub @ScanRoute
pop dx1
pop x5 ; x5 is distance we could travel east
pop x4 ; x4=false if we could move full distance east
pop destx
pop trydir
pop GoalNowX
 x3=x4
 and x3,result
 if x3<>0 then XRoutesNotFree
;
; Both X routes free from collision, so move in the nearest 
; direction to the side of the npc we've hit
 x3=65488 ; -48
 if GoalNowX<CursorX then PushNpcX ; west
 value=x5
 x3=48
 goto PushNpcX ; east
;
; At least one X route is blocked. If one is free, then use it
.XRoutesNotFree
 x3=65488 ; -48
 if result=false then PushNpcX ; west
 if x5<>false then XRoutesBlocked
 value=x5
 x3=48
 goto PushNpcX ; east
;
; Both X routes are blocked, so choose the route which we can 
; move the furthest
.XRoutesBlocked
 x3=65488 ; -48
 if value>x5 then pushnpcx ; can travel furthest west
 value=x5
 x3=48 ; can travel furthest east
.PushNpcX
;
; If we can't push the npc very far at a right angle, then try 
; pushing him in the direction we want to go...
 if value<7 then @PushNpcAway
 x1=GoalNowX
 x2=GoalNowZ
 add x1,x3
 gosub @DoPushNpc
.PushNpcRet
 ScanNoTargetNpc=false ; use ScanRoute as normal in future
GoalNowX=CursorX
GoalNowZ=CursorZ
pop ACBHeader
pop dx4
 dir=trydir
;***BUG!! ACBList(x1)=c1 ; only freeze for a 1 npc cycle
 goto @MakeNpcStandStill
;
.DontPushNpcX
; In which z direction can we move the furthest?
push GoalNowZ
 GoalNowz=Cursorz ; start scan from our z, not the npc's
push trydir
push destz
 trydir=5
 destz=GoalNowZ
 add destz,c16
 add destz,c8
push dx1
 gosub @ScanRoute
pop dx1
;
push result ; false if we could move full distance east
push value ; value is distance we could travel south
 trydir=1
 destz=GoalNowZ
 sub destz,c16
 sub destz,c8
push dx1
 gosub @ScanRoute
pop dx1
pop x5 ; x5 is distance we could travel south
pop x4 ; x4=false if we could move full distance south
pop destz
pop trydir
pop GoalNowZ
 x3=x4
 and x3,result
 if x3<>0 then ZRoutesNotFree
;
; Both Z routes free from collision, so move in the nearest 
; direction to the side of the npc we've hit
 x3=65512 ; -24
 if GoalNowZ<CursorZ then PushNpcZ ; north
 value=x5
 x3=24
 goto PushNpcZ ; south
;
; At least one Z route is blocked. If one is free, then use it
.ZRoutesNotFree
 x3=65512 ; -24
 if result=false then PushNpcZ ; west
 if x5<>false then ZRoutesBlocked
 value=x5
 x3=24
 goto PushNpcZ ; east
;
; Both X routes are blocked, so choose the route which we can 
; move the furthest
.ZRoutesBlocked
 x3=65512 ; -24
 if value>x5 then pushnpcZ ; can travel furthest west
 value=x5
 x3=24 ; can travel furthest east
.PushNpcZ
;
; If we can't push the npc very far at a right angle, then try 
; pushing him in the direction we want to go...
 if value<4 then @PushNpcAway
 x1=GoalNowX
 x2=GoalNowZ
 add x2,x3
 gosub @DoPushNpc
 goto @PushNpcRet
;
; If we can't push the npc very far at a right angle, then try 
; pushing him in the direction we want to go...
.PushNpcAway
 x1=0 ; x adjust
 x2=65528 ; z adjust
 if trydir=1 then PushNpcAway1
 x1=0 ; x adjust
 x2=8 ; z adjust
 if trydir=5 then PushNpcAway1
 x1=16 ; x adjust
 x2=0 ; z adjust
 if trydir=3 then PushNpcAway1
 x1=65520 ; x adjust
 x2=0 ; z adjust
.PushNpcAway1
 add x1,GoalNowX
 add x2,GoalNowZ ; add adjustments
 gosub @DoPushNpc
 goto @PushNpcRet
;
.DoPushNpc
;
; can't be pushed if we haven't got anywhere for ages
 x1=ACBSearchTime
 add x1,ACBHeader
 &x1=ACBList(x1)
 if x1>CantBePushed then DPNret
;
; use a standard GD routine so that we don't send the obstruction to 
; a blocked square...
;
 object=255 ; safe code to show we're not trying to find a person
 collidewithself=true ; make sure we don't stay in same place!
;
; set a temporary GD status, so that AAML thinks we're already on 
; a GD path, so as not to make the npc stand still at the start of 
; the new GD
 v1=ACBStatus
 add v1,ACBHeader
 v2=ACBGeneralGD
 ACBList(v1)=v2
;
push actor
 Gosub @GetActorFromACB
 gosub @AAMLGotCoords1Vec ; use goal code in aamakelocal
;
 x3=ACBStatus
 add x3,ACBHeader
 x2=ACBPushedAway
 ACBList(x3)=x2 ; set temporary 'pushed' status, so as not to 
; set the 'arrived' flag when the obstruction reaches his temporary 
; destination
;
pop actor
 collidewithself=false
.DPNret
 return
;
; Stand still a while the obstructing npc gets out of the way...
.MakeNpcStandStill
 ReturnCode=999 ; special code to prevent further decisions
 x1=ACBPreviousStatus
 add x1,ACBHeader
 ACBList(x1)=trydir
 x1=ACBHaltDelay
 add x1,ACBHeader
 ACBList(x1)=c1 ; GMJ 2/1/90 - new speed ; c4 ; freeze for a few npc cycles
 return
;---
; Is person with header x1 stood on our target?
.IsPersonStoodOnTarget
 result=false
 x2=ACBXOffset
 add x2,x1
 &x1=ACBList(x2) ; x1 is person x pos
 add x2,c2
 &x2=ACBList(x2) ; x2 is person y pos
 x3=24 ; x3 is xdist for person width
 x4=DestX
 sub x4,x3 ; width of X precision
 if x1<x4 then IPSOTRet ; too far to left.
 add x4,x3
 add x4,x3
 if x1>x4 then IPSOTRet ; too far to right.
 x3=4 ; x3 is zdist for person depth
 x4=DestZ
 sub x4,x3 ; width of Z precision
 if x2<x4 then IPSOTRet ; too far north.
 add x4,x3
 add x4,x3
 if x2>x4 then IPSOTRet ; too far south.
 result=true
.IPSOTRet
 return
;---
.GDcalcFastest
 StartX=GoalNowX
 StartY=GoalNowZ
 if dir=1 then @GDsetNEW
 if dir=3 then @GDsetNES
 if dir=5 then @GDsetESW
 if dir=7 then @GDsetNSW
;
.CalcFastestRoute
 gosub @CalcfastestRoute1
 if result=false then ReverseRoute
;; GMJ 08/11/89 ;; IntendedDir=TryDir
 return
;
; can't go in desired direction, so reverse
.ReverseRoute
; reverse vertically
 gosub @GDUpOrDown
 DestZ=GoalNowZ
 if trydir=5 then ReverseSubZ
 add DestZ,c32 ; dir is 1, reverse by making dest greater
 goto ReverseH
.ReverseSubZ
 sub DestZ,c32
;
; reverse horizontally
.ReverseH
 gosub @GDleftOrRight
 DestX=GoalNowX
 if trydir=3 then ReverseSubX
 add DestX,c32 ; dir is 7, reverse by making dest greater
 goto SetTempDest
.ReverseSubX
 sub DestX,c32
.SetTempDest
 gosub @CalcFastestRoute1 ; calc fastest reversed route
;
; Work out a new IntendedDir at a right-angle to the 
; reverse direction...
push trydir
 if trydir=3 then CFRud
 if trydir=7 then CFRud
 gosub @GDLeftOrRight
 goto CFRnewIntended
.CFRud
 gosub @GDUpOrDown
.CFRnewIntended
 IntendedDir=TryDir
pop trydir
;
 return
;---
; Calculate fastest route by scanning both horizontal and 
; vertical routes - Graham
.CalcFastestRoute1
;
; How far can we go horizontally then vertically?
 gosub @GDleftOrRight
push trydir
 gosub @ScanRoute
push value
 if result=true then GotHVRoute
; no horizontal collision, so continue with vertical
push GoalNowX
 GoalNowX=DestX
 gosub @GDUpOrDown
 gosub @ScanRoute
pop GoalNowX
pop x1 ; horizontal value
 add value,x1 ; add horizontal distance
;
; If HV route is collision-free, then use it straight away
 if result=true then HVNotFree
pop trydir
 IntendedDir=trydir ;; GMJ 08/11/89
 goto @OkGotRoute
;
.HVNotFree
push value
.GotHVRoute
push result
;
; How far can we go vertically then horizontally?
 gosub @GDUpOrDown
push trydir
 gosub @ScanRoute
 if result=true then GotVHRoute
; no vertical collision, so continue with horizontal
push value
push GoalNowZ
 GoalNowZ=DestZ
 gosub @GDLeftOrRight
 gosub @ScanRoute
pop GoalNowZ
pop x1 ; vertical value
 add value,x1 ; add vertical distance
.GotVHRoute
pop trydir
;
; pop values for HV search
pop x2 ; RESULT if we hit anything in horizontal search
pop x5 ; VALUE for horizonral dist
pop x1 ; TRYDIR for horizontal search
;
; If VH route is collision-free, then use it straight away
 IntendedDir=trydir ;; GMJ 08/11/89
 if result=false then OkGotRoute
;
; Choose the shortest route which brings us to an object, 
; BUT don't choose a route that is closely blocked
;; IntendedDir=trydir ;; GMJ 08/11/89
 if value<x5 then UseVHRoute
 IntendedDir=x1 ;; GMJ 08/11/89
;
.UseHVRoute
 if x5<2 then UseVHRoute ; sorry, HV route is closely blocked
 TryDir=x1 ; resume HV trydir
 Value=x5
 goto OkGotRoute
;
.UseVHRoute
 if value>1 then OkGotRoute
; sorry, VH route is closely blocked
 if x5>1 then UseHVRoute ; but it's okay to use VH route
 result=false ; both routes closely blocked
 return
;
.OkGotRoute
 result=true ; found route
.GDCFRet
 return
;---
; Code to handle changes of direction without collisions...
.GDsetESW ;Pick south, else EW
 gosub @GDupOrDown
 if v1=0 then GDLeftOrRight
 if TryDir=1 then GDLeftOrRight
 return

.GDsetNEW ;Pick north, else EW
 gosub @GDupOrDown
 if v1=0 then GdLeftOrRight
 if TryDir=5 then GDLeftOrRight
 return

.GDsetNSW ;Pick west, else NS
 gosub @GDleftOrRight
 if v2=0 then GDUpOrDown
 if TryDir=3 then GDUpOrDown
 return

.GDsetNES ;Pick east, else NS
 gosub @GDleftOrRight
 if v2=0 then GDUpOrDown
 if TryDir=7 then GDUpOrDown
 return

.GDleftOrRight
 v2=DestX    ;destination X
 sub v2,GoalNowX ;end-start
 TryDir=3 ;right
 if v2<32768 then GLR1
 TryDir=7 ;left
.GLR1
 return

.GDupOrDown
 v1=DestZ ;destination Z
 sub v1,GoalNowZ ;end-start
 TryDir=5 ;down
 if v1<32768 then GUD1
 TryDir=1 ;up
.GUD1
 return
;---
; Slightly more intelligent versions of GDupOrDown/leftOrRight
; to avoid objects by finding the nearest edge unless the 
; destination is somewhere along the object
.GDIntelLorR
 gosub @GDUpOrDown
 if v1<5 then @GDLeftOrRight
 if v1>65532 then @GDLeftOrRight
 x1=4
 if dir=5 then GDILR1
 x1=65532 ; -4
.GDILR1
push CurrentSquare
 StartY=GoalNowZ
 add StartY,x1
 StartX=GoalNowX
; StartX,StartY is the blocked square we just tried to 
; move onto. Look ahead east & west to find the nearest 
; unblocked square at the edge of the shape and choose 
; that direction...
 trydir=3 ; try east
 gosub @SearchForUnblocked ; value is distance to unblocked square
;
; but can we get to the egde of the shape on our current plane?
push value
push destx
 if value<>500 then GDILRnotOffScreen1
 destx=316 ; shape was blocked to edge of screen
 goto GDILRgotDest1
.GDILRnotOffScreen1
 destx=goalnowx
 x2=value
 add x2,c2 ; check that we're clear by 2 steps
 add x2,x2
 add x2,x2
 add destx,x2 ; add distance (steps ==> pixels) to edge
.GDILRgotDest1
 gosub @ScanRoute
pop destx
pop value
 if result=false then gofullEavoid ; can go full distance
 value=501 ; (off map hash-distance is 500, so use a greater distance 
; so that the off-map direction is shorter and is given priority)
.gofullEavoid
;
push value
 trydir=7 ; try west
 gosub @SearchForUnblocked ; value is distance to unblocked square
;
; but can we get to the egde of the shape on our current plane?
push value
push destx
 if value<>500 then GDILRnotOffScreen2
 destx=4 ; shape was blocked to edge of screen
 goto GDILRgotDest2
.GDILRnotOffScreen2
 destx=goalnowx
 x2=value
 add x2,c2 ; check that we're clear by 2 steps
 add x2,x2
 add x2,x2
 sub destx,x2 ; add distance (steps ==> pixels) to edge
.GDILRgotDest2
 gosub @ScanRoute
pop destx
pop value
 if result=false then gofullWavoid ; can go full distance
 value=501
;.gdfullavoidW
;
; if we can't get to the egde of the shape either way, then 
; choose at random!
pop x1
push x1
 if x1<>501 then gofullWavoid
pop x1 ; clear stack
code -
 random x1
code +
 and x1,c1
 trydir=3
 if x1=0 then GDILRRet
 trydir=7
 goto GDILRRet
.gofullWavoid
;
pop x1
 if value<x1 then GDILRret ; west is shortest route
 trydir=3 ; east is shortest route
.GDILRret
pop CurrentSquare
 return
;---
.GDIntelUorD
 gosub @GDLeftOrRight
 if v2<5 then @GDUpOrDown
 if v2>65532 then @GDUpOrDown
 x1=4
 if dir=3 then GDIUD1
 x1=65532 ; -4
.GDIUD1
push CurrentSquare
 StartX=GoalNowX
 add StartX,x1
 StartY=GoalNowZ
; StartX,StartY is the blocked square we just tried to 
; move onto. Look ahead north & south to find the nearest 
; unblocked square at the edge of the shape and choose 
; that direction...
 trydir=1 ; try north
 gosub @SearchForUnblocked ; value is distance to unblocked square
;
; but can we get to the egde of the shape on our current plane?
push value
push destz
 if value<>500 then GDIUDnotOffScreen1
 destz=4 ; shape was blocked to edge of screen
 goto GDIUDgotDest1
.GDIUDnotOffScreen1
 destz=goalnowz
 x2=value
 add x2,c1 ; check that we're clear by 1 step
 add x2,x2
 add x2,x2
 sub destz,x2 ; add distance (steps ==> pixels) to edge
.GDIUDgotDest1
 gosub @ScanRoute
pop destz
pop value
 if result=false then gofullNavoid ; can go full distance
 value=501
.gofullNavoid
;
push value
 trydir=5 ; try south
 gosub @SearchForUnblocked ; value is distance to unblocked square
;
; but can we get to the egde of the shape on our current plane?
push value
push destz
 if value<>500 then GDIUDnotOffScreen2
 destz=196 ; shape was blocked to edge of screen
 goto GDIUDgotDest2
.GDIUDnotOffScreen2
 destz=goalnowz
 x2=value
 add x2,c1 ; check that we're clear by 1 step
 add x2,x2
 add x2,x2
 add destz,x2 ; add distance (steps ==> pixels) to edge
.GDIUDgotDest2
 gosub @ScanRoute
pop destz
pop value
 if result=false then gofullSavoid ; can go full distance
 value=501
;
; if we can't get to the egde of the shape either way, then 
; choose at random!
pop x1
push x1
 if x1<>501 then gofullSavoid
pop x1 ; clear stack
code -
 random x1
code +
 and x1,c1
 trydir=1
 if x1=0 then GDIUDRet
 trydir=5
 goto GDIUDRet
.gofullSavoid
;
 pop x1
 if value<x1 then GDIUDret ; south is shortest route
 trydir=1 ; north is shortest route
.GDIUDret
pop CurrentSquare
 return
;---
; Search from StartX,StartY in direction TryDir until we reach 
; a UNBLOCKED square...
.SearchForUnblocked
push dx2
push dx3
push dv2
push dv3
 dx2=0
 dx3=0 ; zero scan adjustments to dv2,dv3
 dv2=StartX
 dv3=StartY
 value=0
.ScanUnblocked
 gosub @CheckMapVec ; square unblocked?
 if Result=false then SUoffMap ; off-map
 if v1=0 then FoundUnblocked
 add value,c1 ; increment distance scanned
 if trydir=3 then SUaddX
 if trydir=7 then SUsubX
 if trydir=5 then SUaddZ
 sub dv3,c4
 goto ScanUnblocked
.SUaddZ
 add dv3,c4
 goto ScanUnblocked
.SUaddX
 add dv2,c4
 goto ScanUnblocked
.SUsubX
 sub dv2,c4
 goto ScanUnblocked
.SUoffMap
 value=500 ; high value if search went off-map
.FoundUnblocked
pop dv3
pop dv2
pop dx3
pop dx2
; VALUE is distance to the next unblocked square in direction TRYDIR
 return
;---
; Scan a route in direction TRYDIR until we reach the target
.ScanRoute
push dx2
push dx3
push dv2
push dv3
 dx2=0
 dx3=0 ; zero scan adjustments to dv2,dv3
 dv2=GoalNowX
 dv3=GoalNowZ
 value=0
.DoScan
 gosub @CheckMapVec
 if v1<>0 then @EndScan ; object in the way
 gosub @CPC0vec ; dx1=0 if no npc's in our way
 if dx1=0 then ScanNoCollision
 if ScanNoTargetNpc=true then @EndScan ; treat target npcs as obstacles
 gosub @IsDx1TargetNpc ; are we trying to find this npc?
 if result=false then @EndScan ; no - so treat as collision
.ScanNoCollision
 add value,c1
 if trydir=3 then TestXScanGreater
 if trydir=7 then TestXScanLess
 if trydir=5 then TestZScanGreater
 sub dv3,c4 ;; GMJ 13/10/89 ;; c2
 if dv3>DestZ then @DoScan
 goto EndScanNoCollision
.TestZScanGreater
 add dv3,c4 ;; GMJ 13/10/89 ;; c2
 if dv3<DestZ then @DoScan
 goto EndScanNoCollision
.TestXScanLess
 sub dv2,c4
 if dv2>DestX then @DoScan
 goto EndScanNoCollision
.TestXScanGreater
 add dv2,c4
 if dv2<DestX then @DoScan
.EndScanNoCollision
 result=false ; no collisions encountered
 goto EndScanOk
.EndScan
 result=true ; collisions encountered
.EndScanOk
pop dv3
pop dv2
pop dx3
pop dx2
; VALUE is distance we can move in TRYDIR
; RESULT true if we collided with something
 return
;---
; Is dx1 the npc Actor is trying to find?
.IsDx1TargetNpc
 gosub @SetActorAttributes
 gosub @GetCurrentCommand ; noun1 is the npc we're trying to find
 if verb=igdfind then FollowingDx1
 if verb<>ifollow then Dx1NotTarget
.FollowingDx1
 object=noun1
 gosub @getobjectposx2VEC ; returns x4 as last object on the ground 
; in the containment chain
 noun1=x4

; g1=ACBObjectOffset
; add g1,dx1
; &g1=ACBList(g1) ; g1 is npc we've collided with
 v1=dx1
 gosub @SetV1Actor
 if noun1<>v1 then Dx1NotTarget ; g1 ; it's not the one we're trying to find

 result=true
 return
.Dx1NotTarget
 result=false
 return
;---
; get current moving animation sequence
.GetMovingAniDv1
 dv1=MovingAnimation
 if ACBHeader<>640 then GMAD1 ; jarvis ACB
 if JarvisHasTray=false then GMAD1
 dv1=JarvisMovingTrayAni ; jarvis moves with a tray
.GMAD1
 return
;---
; get current standing animation sequence
.GetStandingAniDv1
 dv1=StandingAnimation
 if ACBHeader<>640 then GSAD1 ; jarvis ACB
 if JarvisHasTray=false then GSAD1
 dv1=JarvisStandingTrayAni ; jarvis stands with a tray
.GSAD1
 return
;---
.GDmakeMove
; Adjust person's height to that of the terrain...
 x1=15
 and x1,currentsquare
 if x1<>0 then NotChangeHeight ; not a height-coded currentsquare
 gosub @AdjustPersonHeightVec2
 dv4=x2 ; set the desired height
 x1=ACBHoffset
 add x1,ACBHeader
 &ACBList(x1)=dv4
.NotChangeHeight

 gosub @GetMovingAniDv1
 ObjectNumber=dv1
 if ObjectNumber=JarvisMovingTrayAni then GSD3 ; no running with tray
 if running=false then GSD3
 Running=false
 ObjectNumber=RunningAnimation

.GSD3
 add ObjectNumber,trydir
 &x1=ACBList(dx4)
 if x1=ObjectNumber then GDstoreACB

 dir=TryDir
.GSD2
 push dx4
 gosub @ChangeACBdx4
 pop dx4

.GDstoreACB
 v1=ACBintendedDirection
 add v1,dx4
 ACBList(v1)=IntendedDir
;; gosub GDGetFinePos
;; v1=ACBFinePosOffset ;misnomer
;; add v1,dx4
;; ACBList(v1)=v2
 return

;-----

;.GDGetFinePos ;puts low 4 bits of X/Z position in v2
; v1=ACBxOffset
; add v1,dx4
; &v1=ACBList(v1)
; v3=15
; and v3,v1
;
; add v3,v3
; add v3,v3
; add v3,v3
; add v3,v3 ;v3 = xxxx0000
;
; v1=ACBzOffset
; add v1,dx4
; &v1=ACBList(v1)
; v2=15
; and v2,v1 ;v2 = 0000zzzz
;
; or v2,v3 ;v2 = xxxxzzzz
; return

;-----

.GDpointOnMap
cif BadRoomOK
 if CurrentRoom=0 then GPM1 ;for editor, must INIT room first
cend
 if CurrentRoom=0 then GPM2 ;for games, room is walkable
 if CursorX<MarginX then GPM1 ;*
 v1=MarginX
 add v1,FSizeX
 if CursorX>v1 then GPM1
 if CursorX=v1 then GPM1 ;*
 if CursorZ<MarginZ then GPM1
 v1=MarginZ
 add v1,FSizeZ
 if CursorZ<v1 then GPM2
.GPM1
 ReturnCode=0
 return

.GPM2
 ReturnCode=1
 return

;-----

.GDquadMask
;Calculate mask for current quadrant
 v2=CursorZ
 and v2,c4 ;0=top row 1=bottom row
 v3=CursorX
 and v3,c4 ;0=left, 1=right

 if v2<>0 then GQM1
 v1=1 ;0001
 if v3=0 then GQM2
 v1=2 ;0010
 goto GQM2
.GQM1
 v1=4 ;0100
 if v3=0 then GQM2
 v1=8 ;1000
.GQM2
 return

;-----

.GDreadSquare
 if CurrentRoom=0 then NoData ;*
 gosub GDsquareAddr
 CurrentSquare=FloorMap(v1)
 return
.NoData ;*
 CurrentSquare=48 ;00110000 height=0
 return

.GDsquareAddr
 v3=CursorZ
 sub v3,MarginZ
 asr v3 ;each byte represents an 8x8 area
 asr v3
 asr v3
; (320-32)/4=72
 v2=FSizeX
 asr v2
 asr v2
 asr v2
 v1=0
.gds1
 if v2=0 then gds2
 add v1,v3
 sub v2,c1
 if v2>0 then gds1

.gds2
 v2=CursorX
 sub v2,MarginX
 asr v2
 asr v2
 asr v2
 add v1,v2
 add v1,CurrentRoom
 return
