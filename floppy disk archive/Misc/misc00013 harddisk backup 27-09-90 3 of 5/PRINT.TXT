; PRINT.TXT for Blood Relations
;
; Mike Austin July 1990
;
; Copyright (C) 1990 Level 9 Computing Ltd
;
;
const
 TextBufferNumber=24 ; where characters are put by MESSAGE commands
 FontListNumber=26
 LoLongTextBufferOffset=166
 ForceUpperCase=0
;
var
 Txposoffset ; x offset for plotting border
 Typosoffset ; y offset for plotting border
;
table
 FontList=26
begin

;------------
.CopyFilename
; from IntroTables(v1) to list17(8)
 v2=8
.CF2
 v3=IntroTables(v1)
 list17(v2)=v3
 add v1,c1
 add v2,c1
 if v3<>0 then CF2
 return
;----
.AllocateAndLoadFont
 &x1=longws(HiLongFreeWorkspace)
 &list11(96)=x1 ; set up list24 - used for text print buffer
 &x1=longws(LOLongFreeWorkspace)
 &list11(98)=x1 ; set up list24
 v1=1024 ; reserve space for list 24 - used for text print buffer
; Big enough for 6.5 lines 80 characters across
 gosub @MCReserveMemory
 &x1=longws(HiLongFreeWorkspace)
 &list11(104)=x1 ; set up list26
 &x1=longws(LOLongFreeWorkspace)
 &list11(106)=x1 ; set up list26
 v1=4200 ; 2048 ; reserve space for list 26 - used for font file
 gosub @MCReserveMemory
 &v1=IntroTables(28) ; offset of filename within IntroTables
;
.LoadFontV1
; from IntroTables(v1) to list17(8)
 gosub @CopyFilename
 v1=FontListNumber
 v2=0
 gosub @MCLoadFile ; at v2 bytes into listv1()
 v1=FontListNumber
 v2=0
 v3=0
 gosub @MCSetPrintFont
; v1=list number, v2=offset, v3=CGA palette code (mono machines only)

; Format of font header (same as PC, of course) is:
;0  .w Offset of "Information"
;2  .w Offset of "width table"
;4  .w offset of "font definition"
;
; "Information" table contains:
;  .b Version. Ignored at present
;  .b SystemWorkspace (0) To allow us to tell if we've done initialise
;  .b First Ascii char
;  .b Last Ascii char
;  .b character width(pixels) divided down to give bytes
;  .b character height (pixels) 
;  .b Number of bit-planes. Normally 1
;  .b Non-zero if compressed (?)
 &x1=FontList(0)
 add x1,c2
 FirstAsciiInFont=FontList(x1)
 add x1,c3
 FontHeight=FontList(x1)
 sub FontHeight,c3 ; reduce vertical spacing of Long Island Font
 return
;---
.DoTextWindow
; text raster is number 1725
 v1=ArcBigWindowRaster ; =1725 (use 431 to display)
; flag display system to show this box
 TextBoxDisplayed=ArcBigWindowDO
 TextBoxWidth=DefaultTextWidth ; 224in Grange Arcades. ; width of main window box

.BoxMessageM1
; print message m1 into text raster v1, clearing it to white first
 gosub @SetupPrintRaster
 code -
  gosub @iMessageM1
 code +
 return
;--------------
 code -
.iMessageM1
; print Message M1 at current cursor pos
 gosub @iStartPrintToBuffer
 message cr ; ensure buffer is flushed
 code +
 &WordWS(WordTextBufferOffset)=c2 ; throw out any junk flushed
 code -
 message m1
 message cr ; ensure buffer is flushed etc.
 gosub @iEndPrintToBuffer
; text has been printed between TextBuffer(2..v7)

.iDisplayBufferedText
; called from menu etc. where several messages are to be put
; into one text box
code +
 if v7>5 then iBoxV1SomeText ; slightly higher than ideal (2)
; because stray spaces, carriage returns etc. tend to get shoved
; out from time to time.

; nothing printed - flag display system to not show this box
 TextBoxDisplayed=0 ; reset flag to indicate no text printed

.iBoxV1SomeText
 v6=FontHeight ;copy into a variable int mode can access
 &x6=FontList(2) ; get offset of width table
 sub x6,FirstAsciiInFont ; so FontList(x6+v3) is width for char v3
;
; Plot black border around text to be printed
 v4=7 ; foreground color black
 Txposoffset=0
 Typosoffset=0
code -
 gosub @DBTloop
code +
 add Txposoffset,c2
code -
 gosub @DBTloop
code +
 add Typosoffset,c2
code -
 gosub @DBTloop
code +
 sub Txposoffset,c2
code -
 gosub @DBTloop
code +
; Plot the text
 v4=1 ; foreground color white
 Txposoffset=1
 Typosoffset=1
; fall through...
;
code -
.DBTloop
 x1=2 ; position in buffer
 v5=0 ; background color
 v2=0 ; y pos
code +
 add v2,Typosoffset ; add pixel ofset
code -

.RasterPrintYLoop
 v1=0 ; x position
code +
 add v1,Txposoffset ; add pixel offset
code -

.RasterPrintXLoop
 v3=TextBuffer(x1) ; ascii code
 add x1,c1 ; step on to next character in buffer
 if v3=96 then @NeedCR ;'`' (next to BS)
 if v3=32 then RPLCheckWordWrap
 if v3<>13 then RPL1
.RPLCheckWordWrap
; check if next word to be printed will fit on this line
 v3=32 ; convert cr, control codes to spaces
 x2=x1
 x4=0 ; cumulative width so far
.CWW1
 x3=TextBuffer(x2)
 if x3<33 then CWW2 ; space,cr,end of message
 if x3=96 then CWW2
 add x3,x6 ; offset of width table
 x3=FontList(x3)
 add x4,x3 ; add on width
 add x2,c1 ; next char
 goto CWW1

.CWW2
; x4 is cumulative width in pixels of next word to be printed
 add x4,v1 ; add on to current x position
 if x4<TextBoxWidth then RPL1
.NeedCR
 add v2,v6 ; y position
 goto RasterPrintYLoop

.RPL1
cif ForceUpperCase
 if v3<97 then RPL1a ; 'a'
 if v3>122 then RPL1a ; 'z'
 x4=32
 sub v3,x4 ; convert it to upper case

.RPL1a
cend

; if v3<>32 then RPL1notspace
; add v1,c4
; goto RPL1done
;.RPL1notspace
code +
 gosub @MCRasterPrintCharacter
code -
; v1=x pos v2=y pos, v3=ascii code, v4=foreground colour (0..16)
; v5=background colour (0..16)
; returns v1=x,v2=y position after print
.RPL1done
 if x1<v7 then RasterPrintXLoop
 return
;------------
.iStartPrintToBuffer
 v1=0				;1=buffers, 2=Logical, 4=Physical
 code +
 gosub @MCEnableTextBuffer	;Select output destination
 &WordWS(WordTextBufferOffset)=c2
; all future text printing
; to this offset within list TextBuffer(), please
;          /* Parameters:
;                 V1 = destination raster
;                 V2 = source raster or clear color
;                 V5 = 2; /+ copy raster +/ 0=clear to color
 code -
 return

.iEndPrintToBuffer
; stop printing into the text buffer, and return v7 as the offset
; within it. Any offset >2 indicates that something has been
; printed.
 v1=7				;1=buffers, 2=Logical, 4=Physical
 code +
 gosub @MCEnableTextBuffer	;Select output destination
 &v7=WordWS(WordTextBufferOffset)
 sub v7,c1 ;**********
 &WordWS(WordTextBufferOffset)=c0
; all future text printing
; to this offset within list TextBuffer(), please
;          /* Parameters:
;                 V1 = destination raster
;                 V2 = source raster or clear color
;                 V5 = 2; /+ copy raster +/ 0=clear to color
 code -
 return
;-------------------
 code +
.SetUpPrintRaster
; prepare to print message m1 into text raster v1, clearing it to white first
 push v1 ; changed by MCSetPrintRaster?
  gosub @MCSetPrintRaster
 pop v1
; clear raster before printing onto it
;; v1=destination raster
 v2=0 ; clear color. 1=white
 v5=0 ; clear to color
 goto @MCRasterHandler

;----------------
