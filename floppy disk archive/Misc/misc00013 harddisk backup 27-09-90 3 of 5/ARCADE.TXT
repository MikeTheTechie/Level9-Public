; Arcade game code for Blood Relations
;
; Mike Austin 29 May 1990
;
; Copyright(C) 1990 Level 9 Computing Ltd.
;
; Necessary changes for integration with GRANGE main game:
;
; Call to SpecialAniObject in DISPLAY.TXT must preserve dv1
;
var
 PlayerX PlayerY ; current position (set by SpecialAniShift)
 PlayerDirection
 Walking
 MazeObjectHeader ; set up by SpecialRasterObject - StructureBuffer(..)
; is the raster giving the map layout for the current maze
; result
 left right top bottom ; collision flags, compiled mode only
 StopPlayerAnimation ; have hit a wall?
 PitBase ; offset of pit coords within MazeList()
 CurrentPit ; pit which is currently being recorded
 QueueObject QueueRasterOffset
 WantedDirection ; last direction actively requested by user  - to
; latch the direction request
 PreventControl ; countdown timer

; bee-game specific vars...
 BeeInFlight
 BeeX BeeY ; starting coords (may be changed to current pos later)
 BeeACB
 BeeSize
 BeeFlightPath
 BeeFlightSteps
 MaxBees
 Swatting

; ridge-specific vars
 FallingDirection
 GameOverTimer
 PermissibleFaults

; bag-specific vars
 CurrentDigitTurn CurrentLock
 TurnCounter ; disables control whilst a dial is counting

; grapple-specific variables
 PlayerForce ComputerForce
 CurrentGunObject
 ComputerStrength PlayerStrength ; 4 times pixel height of indicator bar
 ComputerAttacking  ; a countdown timer
 beesSwatted ; number of bees swatted so far in bee game.

const
 ArcBigWindowRaster=840
 DefaultTextWidth=224
 PlayerWalkBase=2400 ; to which is added the direction
 PlayerWalkNorth=2401
 PlayerStopBase=2410
 PlayerStandNorth=2411
 ClockTurnBase=2430 ; turn clockwise animation base.
 AntiClockTurnBase=2431 ; turn anticlockwise animation base.
; interleaved with ClockTurnBase
 PlayerZ=192
 ClueFlag=139

; ridge-specific constants
 FallingUp=1
 FallingDown=2
 FallingTooFar=3 ; set when start to fall too far.

; grapple-specific constants
 MaxForce=10
 MinSigForce=4
 MinNegSigForce=65532 ; -4
 MinSigForcePlus1=5
 MinNegSigForceMinus1=65531 ; -4
 MinFastForce=6
 MinNegFastForce=65530 ; -6
 InitialStrength=608 ; 38*16

table
 MazeList=16 ; list16 is floor map in main game 4.8K is available

begin
 code +
.ArcadeGame
.OverlayEntryPoint ; entry from main game, SubGame already set up
 TextWindowXOffset=0
 TextWindowHOffset=0
 if SubGame=9 then @SAVE ; save game status
 if SubGame=10 then @LOAD ; load game status

 gosub @MCPurgeAllCells
 v1=IntroTablesList
 &v2=IntroTables(32) ; arcade sprites filename
 gosub @MCOpenSpriteFile
 &v1=IntroTables(22) ; 's2.dat'
 gosub @LoadStructuresV1
; Load intro font
 &v1=IntroTables(28)
 gosub @LoadFontV1

 cif pc
  v1=100 
  gosub @MCSetMaxFrameRate
 cend
 gosub @IntroInit ; set full screen graphics window
 gosub @InitACBs

 Game=0 ; no game being played, so no special sprites etc.
 if SubGame=5 then ChooseGameLoop ; overlay doc game on main game screen
 if SubGame=6 then ChooseGameLoop ; overlay choose game menu
 gosub @SetIntroPalettes

.ChooseGameLoop
; Demo mode, SubGame=0, Main game, SubGame=game no.
 if SubGame=8 then @CourtRoom ; court room sub-game
 if SubGame=11 then @LoseGame ; court room sub-game
 if SubGame<1 then ChooseGame1 ; demo mode
 if SubGame>6 then ChooseGame1
.GotSubGame
 v1=48 ; "0"
 add v1,SubGame ; convert subgame to numeric ascii value
 goto ChosenGame ; treat as if we hit the key
;
.ChooseGame1
 Game=0 ; no game being played, so no special sprites etc.
 m1=2 ; choose game
 gosub @DoTextWindow  ; like BoxMessageM1, but sets up raster num v1 itself
 gosub @DisplayEverything
 TextBoxDisplayed=false
 gosub @ClearKBD
.ChooseGameFastLoop
 gosub @WaitKey
 if v1=48 then @CloseDown ;'0'
 if v1=55 then @IntroSequence ; 6 is intro sequence
 if v1<49 then @ChooseGameLoop
 if v1>54 then @ChooseGameLoop
;
; display instructions for game chosen
.ChosenGame
 m1=v1
 x1=28
 sub m1,x1 ; m1=instructions
 if v1=54 then SelectMurder ; main game - select murder
;
 if v1<>49 then NotMazeGame ;'1'
 gosub @PlayMazeGame
 goto @ReturnToGame
;
.NotMazeGame
 if v1<>50 then NotGunGrapple ;'2'
 gosub @GunGrapple
 if won=true then @courtroom ; won grapple - court room
 goto @ReturnToGame
;
.NotGunGrapple
 if v1<>51 then NotBees ;'3'
 gosub @PlayBeeGame
 goto @ReturnToGame
;
.NotBees
 if v1<>52 then NotRidge ;'4'
 gosub @PlayRidge
 goto @ReturnToGame
;
.NotRidge
 if v1<>53 then @ChooseGameFastLoop ;'5'
 gosub @PlayBag
 goto @ReturnToGame
;
; Select murder number for main game
.SelectMurder
 gosub @DoTextWindow  ; choose murder number
 gosub @DisplayEverything
 TextBoxDisplayed=false
 gosub @ClearKBD
 gosub @WaitKey
 murder=v1
 x1=48
 sub murder,x1
 if murder<1 then SelectMurder
 if murder>5 then SelectMurder
; swap murders 1 & 2
 x1=1
 if murder=2 then setmurderx1
 x1=2
 if murder<>1 then dontsetmurderx1
.setmurderx1
 murder=x1
.dontsetmurderx1
 gosub @SetUpMainGame
 gosub @HardInit
 gosub @RestartGameInit
 gosub @CalcMaxScore ; work out maximum score
code -
 message 2100 ; welcome message
code +
 v1=51 ; '3'
 v2=0 ; offset into AcodeFunctions
 goto @MCCallOverlay
;
; returns here after sub-game...
.ReturnToGame
 if SubGame=0 then @ChooseGameLoop ; demo mode
;
; Set up screen, font, gamedata & graphics files for main game
.SetUpMainGame
 textboxdisplayed=0
 &WordWS(WordTextBufferOffset)=c0
 IBMScrollOffset=c0
 v1=0			;X1
 v2=319			;X2
 v3=0			;Y1
 v4=IBMclipPosition	;Y2
 gosub @MCSetGraphicsWindow	;For clipping sprites
;
; Load game font
 &v1=IntroTables(12)
 gosub @LoadFontV1
 gosub @MCPurgeAllCells
 v1=IntroTablesList
 &v2=IntroTables(34) ; main game sprites filename
 gosub @MCOpenSpriteFile
;
; v1 is ascii code: e.g. gamedat1.dat
; Loads in gamedata but does not affect acode file.
; Remember that list1..9 pointers will be changed,
; with the exception that any pointers equal to 0 in the new
; table.txt/dat will not change the existing pointers
 v1=51 ; '3'
; murders 1-2 use gamedat3.dat, murders 2-3 use gamedat4.dat ETC...
 x1=murder
 sub x1,c1
 asr x1
 add v1,x1
 gosub @MCLoadGamedata
 goto @LoadGameStructures ; & return to main game
;---
.DisplayInstructions
 gosub @DoTextWindow  ; show sub-game instructions
 gosub @DisplayEverything
 TextBoxDisplayed=false
 gosub @ClearKBD
 goto @WaitKey
;---
.GunGrapple
 Game=GrappleGame
 gosub @MCEmptyRoom
 gosub @InitACBs
 gosub @MazeInit
 dv1=20 ; gun grapple scene
 gosub @PreloadAndInsertDV1
 v1=0 ; x coord
 v2=0 ; y coord
 gosub @MCBuildRoom
 gosub @DisplayInstructions ; show instructions over game scene
 GameOver=0 ; not over yet
 GameOverTimer=0
 ComputerStrength=InitialStrength ; 40*16 (max length is 44)
 PlayerStrength=InitialStrength ; 40*16
 PlayerForce=0
 ComputerForce=0

.GunGrappleLoop
 gosub @GetControls
; PlayerSX=x5*2,PlayerSY=x6*2
 gosub @GrappleIntelligence
 gosub @GrappleControls
 gosub @DisplayEverything
 gosub @ProcessQueue ; add any acb requested recently

 gosub @KeyScan ; also provides for escape
 gosub @KeyScan ; also provides for escape
 gosub @KeyScan ; also provides for escape
 gosub @KeyScan ; also provides for escape
 if GameOverTimer=0 then GGNoTimer
 add GameOverTimer,c1
 if GameOverTimer>12 then GrappleGameOver

.GGNoTimer
 if GameOver=false then @GunGrappleLoop
.GrappleGameOver
 m1=60
 add m1,won
 gosub @DoTextWindow  ; like BoxMessageM1, but sets up raster num v1 itself
 gosub @DisplayEverything
 TextBoxDisplayed=false
 gosub @ClearKBD
 goto @WaitKey
;-------------
.GrappleIntelligence
; make computer's decision as to force to apply:
; returns: ComputerForce
 if ComputerAttacking=0 then GINoAttack
 sub ComputerAttacking,c1
 goto GI0aa

.GINoAttack
 code -
 random x1
 code +
 if x1>32 then GI0aa
 asr x1 ; divide by 2 to get time for attack 0..16
 ComputerAttacking=x1

.GI0aa
 x1=ComputerForce
 x2=2 ;  MinSigForce. This sets the force level at which strength
; starts to recover.
 sub x1,x2
 sub ComputerStrength,x1
 if ComputerStrength<32000 then GI0a
 ComputerStrength=0

.GI0a
 if ComputerStrength<InitialStrength then GI0
 ComputerStrength=InitialStrength ; only recharge to  initial value
.GI0

 x1=PlayerForce
 sub x1,x2
 sub PlayerStrength,x1 ; will recharge if force is low
 if PlayerStrength<32000 then GI0b
 PlayerStrength=0

.GI0b
 if PlayerStrength<InitialStrength then GI0c
 PlayerStrength=InitialStrength ; only recharge to initial value

.GI0c

; if PlayerStrength<32000 then GI1
; PlayerStrength=0
;
;.GI1
; if ComputerStrength<32000 then GI1a
; ComputerStrength=0
;
;.GI1a

 x3=0 ; amount to add on to computerForce
 x1=PlayerForce
 sub x1,ComputerForce
 if x1>32000 then GI2
 if x1<MinSigForcePlus1 then GI2b ; GI3 ; no significant difference - don't change
; player is pushing much harder than computer, so increase force
 code -
  random x2
 code +
 x3=0
 if x2>200 then GI3 ; make computer react more slowly, to make game easier
 x3=1 ; added on
 goto GI3

.GI2
 if x1>MinNegSigForceMinus1 then GI2c
; computer is pushing much harder than player, so decrease force
 code -
  random x2
 code +
 x3=0
 if x2>80 then GI3 ; make computer react more slowly, to make game easier

 x3=65535 ; added on
 goto GI3

.GI2b
; player is pushing slightly less than computer, but not
; enough for computer to be gaining. So, computer can reduce
; its force setting slightly
 sub x1,c1
 if x1<MinNegSigForce then GI3
.GI2c
 x3=65535 ; added on

.GI3
 x2=PlayerStrength
 sub x2,ComputerStrength
 if PlayerStrength<10 then GI4a
 if ComputerAttacking<>0 then GI4a
 if x2>32000 then GI4 ; -ve
 if x2<50 then GI5
; computer is losing!
 goto GI5 ; not sure what to do here!

.GI4
 if x2>65490 then GI5
; computer is winning - let's apply enough force to gain on player
 if x1<32000 then GI4b ; player is pushing harder!
.GI4a
 if x1<MinNegSigForce then GI5 ; pushing much harder already
.GI4b
 code -
  random x2
 code +
 x3=0
  if x2>200 then GCRet ; make computer react more slowly to make it easier.
 x3=1

.GI5
 add ComputerForce,x3 ;  ComputerForce=5
 if ComputerForce<32000 then GI6
 ComputerForce=0
.GI6
 if ComputerForce<MaxForce then GI7
 ComputerForce=MaxForce
.GI7
 if ComputerStrength>0 then GCRet
 ComputerForce=0

.GCRet
 return
;------------
.GrappleControls
;; if x6>32000 then GC2
 if x6=0 then GCChangeDirection ; computer may have changed force setting
 if x6>32000 then @GrappleCLessForce

.GC2
; something pressed - so apply more force.
 if PlayerForce>MaxForce then GC3 ; at maximum already
 add PlayerForce,c1

.GC3
.GCChangeDirection
 ObjectNumber=2502 ; in middle, oscillating
 x1=PlayerForce
 sub x1,ComputerForce
 if x1<MinSigForce then GC5 ; below significance threshold
 if x1>MinNegSigForce then GC5 ; below -ve significance threshold
; x1<>0, and beyond significance threshold


 ObjectNumber=2507 ; left person gaining fast
 if x1<32000 then GC4
 if x1<MinNegFastForce then GC5
.GC4
 if x1>32000 then GC4b
 if x1<MinFastForce then GC4b
 ObjectNumber=2512 ; right person gaining fast
 goto GC5

.GC4b
 ObjectNumber=2505 ; left person gaining (opponent)
 if PlayerForce<ComputerForce then GC5
 ObjectNumber=2510 ; right person gaining (sam)

.GC5
; check if one player has won
 if ObjectNumber<2505 then GCNoWin
; computer won?
 dx4=PlayerACB
 gosub @ReadACBdx4 ; get coords
 x1=160
 add dv2,x1 ; get coords centred around screen, not around 0
 if dv2<190 then GCNoComputerWin
 if ObjectNumber>2509 then GCNoComputerWin ; player fighting back
 ObjectNumber=2515 ; start win sequence
 won=false
 goto GCNoWin

.GCNoComputerWin
 if dv2>130 then GCNoPlayerWin ; -20
 if ObjectNumber<2510 then GCNoPlayerWin
 won=true
 ObjectNumber=2520 ; start player win sequence

.GCNoPlayerWin
.GCNoWin

 if CurrentGunObject=ObjectNumber then GC6
 if GameOverTimer>0 then GC6 ; shot has been fired -
; don't revert to ordinary gun now.
 CurrentGunObject=ObjectNumber
 dx4=PlayerACB
 gosub @ChangeACBdx4 ; change acb dx4 to use ani object ObjectNumber

.GC6
 if PlayerStrength>0 then GC7
 PlayerForce=0

.GC7
 return
;-------
.GrappleCLessForce
; no key pressed, so start to reduce the
; force the player is applying
 if PlayerForce=0 then GrappleCRet
 sub PlayerForce,c1

.GrappleCRet
 goto @GCChangeDirection
;-----------------
.PlayBag
 Game=BagGame
 gosub @InitACBs
 gosub @MazeInit
 dv1=215 ; bag scene
 dv3=450
 dv4=450
 gosub @PreloadAndPlotDV1
 gosub @MCCopyScreenToBuffer
 gosub @DisplayInstructions ; show instructions over game scene
 GameOverTimer=0 ; timer not running
 GameOver=false
 Won=false

.BagLoop
 gosub @GetControls
; PlayerSX=x5*2,PlayerSY=x6*2
 gosub @LockControls
 gosub @DisplayEverything
 gosub @ProcessQueue ; add any acb requested recently
 gosub @KeyScan ; also provides for escape
 gosub @KeyScan ; also provides for escape
 gosub @KeyScan ; also provides for escape
 gosub @KeyScan ; also provides for escape
 if GameOverTimer=0 then BagLoop1
 add GameOverTimer,c1
 if GameOverTimer>12 then BagGameOver

.BagLoop1
 if GameOver=false then @BagLoop

.BagGameOver
 m1=40 ; victory message
 if Won=true then BagEnd2
 m1=41 ; failure message
.BagEnd2
 gosub @DoTextWindow  ; like BoxMessageM1, but sets up raster num v1 itself
 gosub @DisplayEverything
 TextBoxDisplayed=false
 gosub @ClearKBD
 goto @WaitKey
;------------
.DisplayLock
 if TurnCounter=0 then DL0
 sub TurnCounter,c1

.DL0
 &x4=IntroTables(30)
; IntroTables(x4) is current combination
; IntroTables(x4+4) is correct combination of lock
 v2=185 ; x coord of first lock
 v3=400 ; z
 v4=327 ; h
 v5=dPlot
 v6=0 ; no reflection
 x3=0 ; number of digit (0..3): counts four digits in lock

.DL1
 v1=IntroTables(x4) ; current lock digit
 x1=6363 ; base for numbers (0..9)
 if x3<>CurrentLock then DL2
 if CurrentDigitTurn=0 then DL2
 x1=6373 ; base for turning on to next highest digit
 if CurrentDigitTurn<32000 then DL2 ; turning +ve: increasing number
 sub x1,c1
 if v1>0 then DL2
 x1=6382 ; 0->9

.DL2
 x2=v1 ; save current digit
 add v1,x1
 push v2 ; x coord
 push v4 ; h coord
  if TurnCounter<>1 then DLNotCorrect
  if x3<>CurrentLock then DLNotCorrect
  x1=4
  add x1,x4
  x1=IntroTables(x1) ; correct?
  if x1<>x2 then DLNotCorrect
  sub v2,c1 ; make digit shudder slightly when correct
  sub v4,c1 ; make digit shudder slightly when correct

.DLNotCorrect
  gosub @MCDrawObjectV1
 pop v4 ; h coord
 pop v2 ;x coord
 if CurrentLock<>x3 then DL4

; and display pointer to lock
 push v4 ; h coord
  x1=12
  sub v4,x1 ; drop pointer down a bit from actual dial
  v1=1130 ; pointer raster
  gosub @MCDrawObjectV1
 pop v4

; actually do turn of dial
 v1=IntroTables(x4)
 add v1,CurrentDigitTurn
; make it wrap round...
 x1=10
 if v1<32000 then DL3a
 add v1,x1 ; negative

.DL3a
 if v1<10 then DL3
 sub v1,x1 ; too positive
.DL3
 IntroTables(x4)=v1
 CurrentDigitTurn=0

.DL4
 add v2,c8 ; next digit
 add x4,c1 ; next digit in table
 add x3,c1 ; next digit number
 if x3<4 then @DL1

 return
;-----------
.LockControls
; have called GetControlsRecently
; PlayerSX=x5*2,PlayerSY=x6*2
 CurrentDigitTurn=0 ; not turning

 if FireKey=0 then @LockCNotFire
; when fire key down, try opening lock, but don't
; allow controls to be used
; is current combination right?
 &x4=IntroTables(30)
 x3=x4
 add x4,c4
; x3 points to current combination, x4 points to correct combination
 x5=4 ; digits to check
.LockCTryLoop
 x1=IntroTables(x4)
 x2=IntroTables(x3)
 if x1<>x2 then LockCRet
 add x3,c1
 add x4,c1
 sub x5,c1
 if x5>0 then LockCTryLoop
 GameOverTimer=1 ; start timer
 Won=true
 ObjectNumber=2760 ; lock opening
 gosub @StartFreeACB0 ;ObjectNumber, returns dx4 at coords 0

.LockCRet
 return


.LockCNotFire
 if x5=0 then LockC2
; change current lock
 if CurrentLock=0 then LockCNoLeft
 if x5<32000 then LockCNoLeft
 sub CurrentLock,c1
 return

.LockCNoLeft
 if CurrentLock>2 then LockCNoRight
 if x5>32000 then LockCNoRight
 add CurrentLock,c1

.LockCNoRight
.LockC2
 if TurnCounter>0 then  LockCNoUpDown ; dial currently moving
; now check for up/down on current lock
 &x4=IntroTables(30)
; IntroTables(x4) is current combination
; IntroTables(x4+4) is correct combination of lock
 add x4,CurrentLock
 x1=IntroTables(x4)
 if x6=0 then LockCNoUpDown
 TurnCounter=3 ; stop any further motion until turn has
; been displayed
 if x6>32000 then LockCNoUp
 CurrentDigitTurn=1 ; add on to number
 return

.LockCNoUp
 CurrentDigitTurn=65535 ; add on to number->decreases it
 return

.LockCNoUpDown

.LockControlsFire
 return
;----------
.PlayRidge
 Game=RidgeGame
 gosub @MCEmptyRoom
 gosub @InitACBs
 gosub @MazeInit

 dv1=160 ; ridge scene
 gosub @PreloadAndInsertDV1
 v1=0 ; x coord
 v2=0 ; y coord
 gosub @MCBuildRoom
 gosub @DisplayInstructions ; show instructions over game scene

 FallingDirection=0
 GameOverTimer=0
 Won=false
 PermissibleFaults=250 ; number of frames on which player
; can apply the wrong correction, before we fall off.

.RidgeLoop
 gosub @GetControls
; PlayerSX=x5*2,PlayerSY=x6*2
 gosub @RidgeControls
 gosub @DisplayEverything
 gosub @ProcessQueue ; add any acb requested recently

 if FallingDirection<>FallingTooFar then NotGameOverTimer
 add GameOverTimer,c1
 if GameOverTimer>12 then RidgeEnd

.NotGameOverTimer
 gosub @KeyScan ; also provides for escape
 gosub @KeyScan ; also provides for escape
 gosub @KeyScan ; also provides for escape
 gosub @KeyScan ; also provides for escape
 if GameOver=false then @RidgeLoop
.RidgeEnd
 m1=30 ; victory message
 if Won=true then RidgeEnd2
 m1=31 ; failure message
.RidgeEnd2
 gosub @DoTextWindow  ; like BoxMessageM1, but sets up raster num v1 itself
 gosub @DisplayEverything
 TextBoxDisplayed=false
 gosub @ClearKBD
 goto @WaitKey
;---
.RidgeControls
 if x6=0 then @RidgeNoControl
 if FallingDirection=FallingTooFar then @RidgeNoControl

 dx4=PlayerACB
 if FallingDirection<>FallingUp then RidgeNotFallingUp
 if x6<32767 then RidgeInstantFallUp
; pulling back on joystick to compensate for fall direction
 ObjectNumber=2692 ; continue after fall up starts
 gosub @ChangeACBdx4 ; change acb dx4 to use ani object ObjectNumber
 FallingDirection=0 ; have corrected for fall

.RidgeNotFallingUp
 if FallingDirection<>FallingDown then RidgeNotFallingDown
 if x6>32767 then RidgeInstantFallDown
; pushing on joystick to compensate for fall direction
 ObjectNumber=2692 ; continue after fall 
 gosub @ChangeACBdx4 ; change acb dx4 to use ani object ObjectNumber
 FallingDirection=0 ; have corrected for fall

.RidgeNotFallingDown
 if FallingDirection<>0 then RidgeNotRHS
 dx4=PlayerACB
 gosub @ReadACBdx4
 if dv2<220 then RidgeNotRHS
; have reached RHS: start animation for sliding through window
 ObjectNumber=2677 ; climb through window animation
 dx4=PlayerACB
 gosub @ChangeACBdx4 ; change acb dx4 to use ani object ObjectNumber
 FallingDirection=FallingTooFar ; don't interrupt animation
 Won=true

.RidgeNotRHS
.RidgeNoControl
 return

.RidgeInstantFallUp
 sub PermissibleFaults,c1
 if PermissibleFaults>0 then RidgeNoControl
 ObjectNumber=2680 ; fall up
 goto @ChangeACBdx4 ; change acb dx4 to use ani object ObjectNumber
;; FallingDirection=FallingTooFar ; uncorrectable

.RidgeInstantFallDown
 sub PermissibleFaults,c1
 if PermissibleFaults>0 then RidgeNoControl
 ObjectNumber=2685 ; fall down
 goto @ChangeACBdx4 ; change acb dx4 to use ani object ObjectNumber
;--------------------------
.PlayBeeGame
 MaxBees=Murder ; bees 1-5
 add MaxBees,MaxBees ; 2-10
 add MaxBees,MaxBees ; 4-20
 Game=BeeGame
 gosub @MCEmptyRoom
 gosub @InitACBs
 gosub @MazeInit

 dv1=151 ; bee scene
 dv3=0
 dv4=0
 gosub @PreloadAndInsertDV1
 v1=0 ; x coord
 v2=0 ; y coord
 gosub @MCBuildRoom
 gosub @DisplayInstructions ; show instructions over game scene

 ObjectNumber=2600 ; hand at rest
 dv2=0 ; x
 dv3=0 ; z
 dv4=65436 ; h
 gosub @StartFreeACB ;ObjectNumber, returns dx4 at coords 0
 PlayerACB=dx4
 GameOverTimer=0 ; number of times stung
 BeesSwatted=0

.BeesLoop
 gosub @BeeIntelligence ; (!)

 gosub @GetControls
; PlayerSX=x5*2,PlayerSY=x6*2
 gosub @ControlHand
 gosub @DisplayEverything
 gosub @ProcessQueue ; add any acb requested recently

 gosub @KeyScan ; also provides for escape
 gosub @KeyScan ; also provides for escape
 gosub @KeyScan ; also provides for escape
 gosub @KeyScan ; also provides for escape
 won=true
 if BeesSwatted=MaxBees then BeesGameOver
 if BeesSwatted>MaxBees then BeesGameOver
 won=false
 if GameOver=true then BeesGameOver
 if GameOverTimer<6 then BeesLoop ; number of times stung
.BeesGameOver
 m1=50 ; failure message
 if Won=false then BGO2
 m1=51 ; success message
.BGO2
 gosub @DoTextWindow  ; like BoxMessageM1, but sets up raster num v1 itself
 gosub @DisplayEverything
 TextBoxDisplayed=false
 gosub @ClearKBD
 goto @WaitKey
;-------------------
.BeeIntelligence
 if BeeInFlight<>7 then BI2
; sting player
  dv1=958 ; big red splat where you got stung
  dv2=BeeX
  add dv2,c32 ; move down and right a bit
  dv3=400 ; z
  add dv3,c32 ; move down and right a bit
  dv4=dv3
  sub dv4,BeeY ; h=z-y
  cif NotPC
   dv5=0 ; insert.
  cend
  cif PC
   dv5=DInsertRedraw
  cend
  dv6=0 ; non-reflected
  gosub @MCDrawObjectDV1
  cif NotPc
   gosub @MCBuildRoom
  cend
 add GameOverTimer,c1 ; number of times stung

.BI2
 if BeeInFlight<>0 then BeesLoop2
 ObjectNumber=2610 ; bee approaching
 dv2=160 ; start bee in centre of screen
 dv3=64
 dv4=65480 ; h
 gosub @StartFreeACB ; ObjectNumber, at coords dv2,dv3,dv4
 BeeInFlight=38
 BeeACB=dx4
 gosub @NewBeeFlightPath ; start first flight path

.BeesLoop2
 Sub BeeInFlight,c1
.BIRet
 return
;---
.ControlHand
; PlayerSX=x5*2,PlayerSY=x6*2
 if x5<>0 then CHMove
 if x6=0 then @CHNoMove
.CHMove
 dx4=PlayerACB
 gosub @ReadACBdx4 ; get dv1..dv4 as object,coords
 add x5,x5
 add x5,x5
 add x5,x5
 add x5,x5
 add dv2,x5
 if dv2<32000 then HandNotOffLeft
 dv2=0
.HandNotOffLeft
 if dv2<281 then HandNotOffRight
 dv2=280
.HandNotOffRight
 add x6,x6
 add x6,x6
 add x6,x6
 add x6,x6
 add dv4,x6
 if dv4<32000 then HandNotOffBottom
 if dv4>65435 then HandNotOffBottom
 dv4=65436
.HandNotOffBottom
 if dv4>32000 then HandNotOffTop
 if dv4<51 then HandNotOffTop
 dv4=50
.HandNotOffTop
 dx4=PlayerACB
 gosub @MoveACBdx4 ; write dv2..dv4 back to acb

.CHNoMove
 v1=FireKeyChange ; pass to int mode
code -
 if FireKey=0 then ControlHandNoFire
 if v1=0 then ControlHandNoFire ; fireKeyChange
code +
 if swatting=true then CHNFret ; prevent auto-swat
 swatting=true
code -
 ObjectNumber=2601 ; hit animation sequence
 dx4=PlayerACB
 gosub @iChangeACBdx4
; change acb dx4 to use ani object ObjectNumber
code +
 return
code -
;
.ControlHandNoFire
code +
 swatting=false
.CHNFret
 return
;---
; Vars passed from main game:
; "MazeObject" - on entry to maze game, contains an object hidden 
; within the maze, or zero if maze is empty
; "MazeObjectTaken" - set to MazeObject on exit from maze 
; game if sam has picked the object up
;
.PlayMazeGame
 MazeObjectTaken=0 ; no objects taken yet
 Game=MazeGame
 gosub @MCEmptyRoom
 gosub @InitACBs
 gosub @MazeInit
 dv1=100 ; maze background
 gosub @PreloadAndInsertDV1
 v1=0 ; x coord
 v2=0 ; y coord
 gosub @MCBuildRoom
 gosub @DisplayInstructions ; show instructions over game scene
 gosub @ControlPlayer
 GameOver=false
 Won=false

.MazeGameLoop
 if PreventControl=0 then NoPreventControl
 sub PreventControl,c1
 goto NoPlayerControl

.NoPreventControl
 gosub @GetControls
; PlayerSX=x5*2,PlayerSY=x6*2
 if x7=0 then NoPlayerControl
 WantedDirection=x7

.NoPlayerControl
 gosub @ControlPlayer

 if PlayerX<160 then MGL1
 if PlayerY<176 then MGL1
 if PlayerY>32000 then MGL1 ; in case we can go -ve
; escaped from maze
 GameOver=true
 Won=true

.MGL1
 gosub @DisplayEverything
 gosub @ProcessQueue ; add any acb requested recently

 gosub @KeyScan ; also provides for escape
 gosub @KeyScan ; also provides for escape
 gosub @KeyScan ; also provides for escape
 gosub @KeyScan ; also provides for escape

 if GameOver=0 then MazeGameLoop

 m1=10 ; sam escaped just in time
 if Won=true then MazeGameOutcome
 m1=11 ; sam was overcome by the fumes
.MazeGameOutcome
 gosub @DoTextWindow  ; like BoxMessageM1, but sets up raster num v1 itself
 gosub @DisplayEverything
 TextBoxDisplayed=false
 gosub @ClearKBD
 goto @WaitKey
;---
.MazeInit
 PlayerX=160
 PlayerDirection=1 ; north at present
 WantedDirection=1 ; want to go north
 PreventControl=12 ; player has no control for first 11 frames
 Walking=true
 StopPlayerAnimation=0
 PitBase=0 ; offset of pit coords within MazeList()
 CurrentPit=0 ; current pit being recorded
 GameOver=false ; not finished yet

; ObjectNumber=PlayerStandNorth ; player standing still, facing north
; dv2=PlayerX
; dv3=PlayerZ
; dv4=PlayerH
; dv5=dPlot ; draw flag
; dv6=0 ; no reflection
; gosub @StartFreeACB
; PlayerACB=dx4
 return
;----------
.ControlPlayer
; have recently called GetControls
 if Walking=true then CP1
; when stopped, start straight into walk animation (no turn)
; iff we're starting off in the direction of the stopped figure.
 if WantedDirection<>PlayerDirection then CP1
 code -
  ObjectNumber=PlayerWalkBase
code +
  v3=PlayerDirection
code -
  goto CPGotTurn
 code +

.CP1
 if PlayerDirection=WantedDirection then @ControlPlayerNoChange ; no change
 x7=WantedDirection
 or x7,c1 ; add in bottom bit to avoid diagonals
 if x7<>9 then CP2
 x7=1
.CP2
 Walking=true
 &v1=IntroTables(24) ; TurnDirection table for clockwise - anticlock
; table is 16 bytes later.
  add v1,PlayerDirection
 code -
  v3=IntroTables(v1) ; what direction we get to by going clockwise
  ObjectNumber=ClockTurnBase
  if v3=x7 then CPGotTurn
  ObjectNumber=AntiClockTurnBase ; otherwise always turn anticlockwise
  add v1,c16 ; anticlockwise table
  v3=IntroTables(v1) ; what direction we get to by going anticlockwise

.CPGotTurn
; turning to direction v3, using animation base ObjectNumber
 code +
  if PlayerDirection<10 then CPGT2
  PlayerDirection=7 ; kludge it
.CPGT2
  add ObjectNumber,PlayerDirection
  PlayerDirection=v3
 code -
  dx4=PlayerACB
 gosub @iChangeACBdx4
; change acb dx4 to use ani object ObjectNumber
 code +

.ControlPlayerNoChange
 Walking=true
; check for "STOP" key


  if StopPlayerAnimation<>0 then StopPlayer
;  v1=107 ; keypad 5
;  gosub @GDKeyDown
  if FireKey=0 then ControlPlayerNoStop
.StopPlayer
  StopPlayerAnimation=0
  ObjectNumber=PlayerStopBase
  add ObjectNumber,PlayerDirection
  dx4=PlayerACB
  gosub @ChangeACBdx4
; change acb dx4 to use ani object ObjectNumber
  Walking=false

.ControlPlayerNoStop
 return
;------------
 code -
.iChangeACBdx4
 code +
  gosub @ChangeACBdx4
 code -
 return
;-----
code +
;----------
;.StartFreeACB ;ObjectNumber, dv2, dv3, dv4; returns dx4
; dv1=ObjectNumber
; gosub @FindObjectNumber
; goto @SetupACB
;;-----
;.SetUpACBdx4
; push dx4
;  gosub @FindObjectNumber
;  gosub @DecodeHeader
; pop dx4
; dv1=ObjectNumber
; gosub @SUAGotBlankACB
; return
;;---
.SpecialXZHObject
; xzh object dv1..6 is going through the acode DrawObjectdv1 routine
 if Game<>MazeGame then sxNotMazeGame
 if dv1<31 then sxNotClue
 if dv1>38 then sxNotClue
 push dv1
  dx2=ClueFlag
  gosub @sxClue
 pop dv1
.sxNotClue
 return
;---
.sxNotMazeGame
 return
;---
.SpecialRasterObject
; raster object dv1..6 is going through the acode DrawObjectdv1 routine

 if Game<>MazeGame then @SRONotMaze
 ObjectNumber=dv1
 gosub @FindAndDecode
 if size<400 then SRONotMap
; a big raster - a map for the maze game
 MazeObjectHeader=header

.SRONotMap
 if dv1<>768 then SRONotPit
 dx2=0 ; flag - not yet revealed
.sxClue
 &MazeList(CurrentPit)=dv2 ; x coordinate
 dx1=dv3 ;
 sub dx1,dv4 ; y=z-h
 add CurrentPit,c2
 &MazeList(CurrentPit)=dx1 ; y coordinate
 add CurrentPit,c2
 &MazeList(CurrentPit)=dx2 ; flag, set when revealed
 add CurrentPit,c2
 &MazeList(CurrentPit)=dv1 ; object number causing pit/clue
 add CurrentPit,c2
 dv1=0 ; prevent it being displayed

.SRONotPit
 return
;----------------
.SRONotMaze
 return
;========================
.ArcadeSpecialAniObject
 dv1=num
; an animation object is drawing frame dv1 at dv2..dv4
; triggered by Animation Object at ACBHeader
 if Game<>RidgeGame then SAONotRidge
 if dv1<1020 then SAONotPlayerACB ; feet sprites are root player acb
 if dv1>1038 then SAONotPlayerACB
 PlayerACB=ACBHeader

.SAONotPlayerACB
 if FallingDirection=FallingTooFar then SAONotFallingDown
 if dv1<>1040 then SAONotFallingNorth
 FallingDirection=FallingUp

.SAONotFallingNorth
 if dv1<>1046 then SAONotFallingDown
 FallingDirection=FallingDown

.SAONotFallingDown
 if dv1<1041 then SAONotBigFall
 if dv1>1051 then SAONotBigFall
 if dv1=1046 then SAONotBigFall
 FallingDirection=FallingTooFar

.SAONotBigFall
 return


;---------------
.SAONotRidge
 if Game<>BeeGame then @SAONotBeeGame
 if dv1<>157 then @SAONotHand
; hand which may hit bee, if it's in the right place
; The hand is an xzh object, centred on the middle of the impact area
 dx1=dv2
 sub dx1,BeeX
 if dx1<32 then SAOHitX
 if dx1<65500 then SAONoHit
.SAOHitX
 dx1=dv3
 sub dx1,dv4 ; y=z-h
 sub dx1,BeeY
 if dx1<BeeSize then SAOHitBee
 dx2=0
 sub dx2,BeeSize
 if dx1<dx2 then SAONoHit
.SAOHitBee
; turn bee into a red splat
 add BeesSwatted,c1
 dx4=BeeACB
 ObjectNumber=2620 ; splat animation
 gosub @ChangeACBdx4 ; change acb dx4 to use ani object ObjectNumber
 BeeInFlight=0

.SAONoHit

.SAONotHand
 if dv1<965 then SAONotBee
 if dv1>985 then SAONotBee
 BeeX=dv2
 BeeY=dv3
 sub BeeY,dv4 ; y=z-h
 BeeSize=32
 if dv1<975 then SAONotBee
 BeeSize=64
; stings player!

.SAONotBee
 return
;-----------------

.SAONotBeeGame
 if Game<>BagGame then SAONotBagGame
 if dv1<>199 then SAONotTimerEnds
; timer has counted out
 GameOverTimer=1 ; start timer

.SAONotTimerEnds
 return
;-------
.SAONotBagGame
 if Game<>GrappleGame then SAONotGrappleGame
 if dv1<21 then SAONotHands
 if dv1>26 then SAONotHands
; acb for hands struggling
 PlayerACB=ACBHeader

.SAONotHands
 if dv1=71 then SAOWin
 if dv1<>73 then SAONotWin
.SAOWin
; flash from gun
 GameOverTimer=11

.SAONotWin
 return
;-----------
.SAONotGrappleGame
 if Game<>MazeGame then SAONotMazeGame
 if dv1<>54 then NotSuffocate
 GameOver=true
 Won=false

.NotSuffocate
 return
;---------
.SAONotMazeGame
 return
;------------
.CheckPitCollision
; player is at coords x=x1, y=x2
; return result=2 if there is a pit there!
; (result=false on entry)
 push x1
 push x2
; add x1,c8 ; get centre of player
; add x1,c6 ; get centre of player
; add x2,c8 ; get centre of player
; add x2,c6 ; get centre of player
 sub x1,c6 ; get centre of player
 sub x2,c6 ; get centre of player
 dx5=PitBase
.CPC1
 &dx6=MazeList(dx5) ; x coord
 add dx5,c2
 if x1<dx6 then CPC2
 add dx6,c8 ; width of hole
 if x1>dx6 then CPC2

 &dx6=MazeList(dx5) ; y coord
 if x2<dx6 then CPC2
 add dx6,c8 ; height of hole
 if x2>dx6 then CPC2
; gota pit! MazeList(dx5+2) is word flag.
 result=2 ; collision with pit
 goto CPCEnd ;  return

.CPC2
 add dx5,c6
 if dx5<CurrentPit then @CPC1

.CPCEnd
 pop x2
 pop x1
.PlayerCDRet
 return
;----------
.PlayerCD
; check for player hitting a wall - in which case, the
; effect is like pressing the stop key
; Return Result=true if collided with a wall, or result=2 if collided
; with a pit (in which case, the return is as for CheckPitCollision)
; x1=PlayerX
; x2=PlayerZ
; sub x2,PlayerH ; x2:=PlayerY
; x1=PlayerX, x2=PlayerY
 x5=15
 and x5,x1
 x6=15
 and x6,x2
; keep x5,x6 as fine x,y coords

 result=false ; no collision
 if x1>320 then PCD1 ; 240
 if x1>180 then PCD2 ; exit door can be walked through

.PCD1
 if x2>176 then @GotCollision ; stop player going back through
; doors at bottom of screen

.PCD2
; collision with pit?
 gosub @CheckPitCollision
 if result<>false then PlayerCDRet

 asr x1
 asr x1
 asr x1
 asr x1 ; get cell-based x coord
 x3=x2 ; save y coord in x3
 asr x2
 asr x2
 x4=65532 ; FFFC
 and x4,x2 ; x4:=PlayerY/4=PlayerPixelY*4
 x2=65520 ; FFF0
 and x2,x3 ; x2:=PlayerPixelY*16
 add x2,x4 ; x2:=PlayerPixelY*16+PlayerPixelY*4 = PlayerPixelY*20
 add x2,x1 ; add on x coord
 add x2,x2 ; times 2, because map is word-based
 add x2,c4 ; skip header
 add x2,MazeObjectHeader
; Now &StructureBuffer(x2) is map square which player is currently on.
; (or, in the case of movement, where player is trying to go to)
 &x1=StructureBuffer(x2)
; x1 is the cell number
 x3=4050
 sub x1,x3
; x1=relative cell number
; 0= left, top blocked
; 1= top blocked
; 2= left blocked
; 3=
; 4= left blocked
; 5=
; 6= top blocked
 if x1<2 then CheckTop
 if x1=6 then CheckTop
; check for just left blocked
 if x1=2 then CheckLeft
 if x1=4 then CheckLeft
; nothing
.PCDRet
 return

.CheckTop
; is player near top of cell?
 if x6<4 then GotCollision ; y fine position
 if x1<>0 then PCDRet
; for 0, top and left is blocked, so drop through
.CheckLeft
 if x5>4 then PCDRet ; x fine position
.GotCollision
 result=true
.SASRet
  return
;-------
.SpecialAniShift
; caller does:
; gosub @SpecialAniShift ; moving dv1 from dv2,dv3,dv4 by dx2,dx3,dx4
; you can change any of these if necessary.
; This is for the acb at ACBList(ACBHeader)

; Animation object dv1: moving from
; dv2,dv3,dv4 by amount dx2,dx3,dx4
 if dv5<>dPlot then SASRet
 if Game<>MazeGame then @SASNotMazeGame

 if dv1>2439 then @SASNotPlayer ; top of turn ani range
 if dv1>2430 then SASPlayer ; within turn ani range
 if dv1>2409 then @SASNotPlayer ; outside walk ani range
 if dv1<2400 then @SASNotPlayer ; not needed, I thought
.SASPlayer
 PlayerACB=ACBHeader
 x1=dv2 ; playerx
 x2=dv3 ; playerz
 sub x2,dv4 ; x2:=PlayerY
 PlayerX=x1
 PlayerY=x2

 add x1,c5 ; offset of sprite within cell
 add x2,c5 ; offset of sprites within cell

 push x1 ; check top left part of sprite
 push x2
  gosub @PlayerCD ; returns result=true if player will hit something
 pop x2
 pop x1
 if result<>false then @SASNotPlayer ; already on a blocked square,
; so don't stop player moving off
 add x1,dx2 ; add on x speed
 sub x2,dx4 ; take off h speed

 push x1 ; check top left part of sprite
 push x2
  gosub @PlayerCD ; returns result=true if player will hit something
 pop x2
 pop x1
 if result=2 then @SASPitCollision
 left=result
 top=result

 add x1,c4 ; check top middle part of sprite
 push x1
 push x2
  gosub @PlayerCD ; returns result=true if player will hit something
 pop x2
 pop x1
 if result=2 then @SASPitCollision
 or top,result

 add x1,c4 ; check top right part of sprite
 push x1
 push x2
  gosub @PlayerCD ; returns result=true if player will hit something
 pop x2
 pop x1
 if result=2 then @SASPitCollision
 or top,result
 right=result

; down, right middle
 add x2,c4
 push x1
 push x2
  gosub @PlayerCD ; returns result=true if player will hit something
 pop x2
 pop x1
 if result=2 then @SASPitCollision
 or right,result

; down, right
 add x2,c4
 push x1
 push x2
  gosub @PlayerCD ; returns result=true if player will hit something
 pop x2
 pop x1
 if result=2 then @SASPitCollision
 or right,result
 bottom=result

; down, middle
 sub x1,c4
 push x1
 push x2
  gosub @PlayerCD ; returns result=true if player will hit something
 pop x2
 pop x1
 if result=2 then @SASPitCollision
 or bottom,result

; down, left
 sub x1,c4
 push x1
 push x2
  gosub @PlayerCD ; returns result=true if player will hit something
 pop x2
 pop x1
 if result=2 then @SASPitCollision
 or bottom,result
 or left,result

; down, left middle
 sub x2,c4 ; y
 push x1
 push x2
  gosub @PlayerCD ; returns result=true if player will hit something
 pop x2
 pop x1
 if result=2 then @SASPitCollision
 or left,result

.DoneCD
; ok, we have left,right,top,bottom as the collision sides for
; the place we're trying to go to
; We could just abort the move if any of them are set. This
; works, but it's better to "round off" the corners.
 gosub @DoShuffle

.SASNotPlayer
 return
;---
.SASNotMazeGame
 if Game<>BeeGame then @SASNotBeeGame
 if ACBHeader<>BeeACB then @SASNotBee

; Move bee according to flight path
 if beesize>63 then NoBeeFlightPath
 &dx2=IntroTables(BeeFlightPath) ; x change
 add beeflightpath,c2
 &dx4=IntroTables(BeeFlightPath) ; h change
 add beeflightpath,c2
 add dx4,dx3 ; align h with z adjustment
 add BeeFlightSteps,c1 ; step on flight path frames
.NoBeeFlightPath

; make bee skip around notepad
 if BeeInFlight>16 then @SASNoHit2 ; too far away
 if BeeInFlight<8 then @SASNoHit2 ; too near
push dx4
 dx4=PlayerACB
 gosub @ReadACBdx4 ; get dv1..dv4 as PLAYER object,coords
pop dx4
; Bee is within notepad z range, but is it within x range?
 x1=dv2
 sub x1,BeeX
 if x1<64 then SASHitX
 if x1<65488 then SASNoHit
.SASHitX
; Bee is within notepad x range, so skip above notepad
 if BeeY>32000 then SASNoHit ; already at top of screen
 if BeeY<24 then SASNoHit
 add dx4,c4 ; jump up
.SASNoHit
push dx4
 dx4=BeeACB
 gosub @ReadACBdx4 ; get dv1..dv4 as PLAYER object,coords
pop dx4
.SASNoHit2

; prevent bee from moving too far off left of screen
 if dv2<32000 then SASNotLeftLimit
 if dv2>65480 then SASNotLimitBeeX
 dx2=4 ; fly right a bit
 goto SASNotLimitBeeX
.SASNotLeftLimit

; prevent bee from moving too far off right of screen
 if dv2<220 then SASNotLimitBeeX
 dx2=65532 ; make it fly left a bit
.SASNotLimitBeeX

 x1=dv3
 sub x1,dv4 ; y=z-h
 if x1<170 then SASNotLimitBeeY
 dx4=4 ; make it fly up a bit.
.SASNotLimitBeeY

 if BeeFlightSteps>15 then NewBeeFlightPath ; new path every 16 frames

.SASNotBee
.SASNotBeeGame
 return
;---
; Set the bee on one of 4 flight paths, each lasting 8 frames
.NewBeeFlightPath
 BeeFlightSteps=0
 &BeeFlightPath=IntroTables(40)	; x,y flight path additions
code -
 random x1
code +
 x2=64
 and x1,x2 ; x1=0 or 64
 add BeeFlightPath,x1 ; use one of 2 flight paths
 return
;---
.SASPitCollision
; we have collided with the pit/object
; at MazeList(dx5-2),MazeList(dx5)
; with flag &MazeList(dx5+2) which was object &MazeList(dx5+4)
 add dx5,c2
 &dx2=MazeList(dx5)
 if dx2=ClueFlag then SASPit2a
 if dx2<>0 then SASPit2 ; already discovered - just stop player dead
.SASPit2a
 &MazeList(dx5)=c1 ; mark as already discovered

 sub dx5,c2
 &v3=MazeList(dx5)
 sub dx5,c2
 &v2=MazeList(dx5)
 v4=0
 v6=0
 v1=768
 if dx2=ClueFlag then SASGotClue
 v5=dInsertRedraw
 gosub @MCDrawObjectV1 ; display pit

 ObjectNumber=2420 ; topple sequence
.SASPitAni
 gosub @QueueAnimation0

.SASPit2
 goto @DSStopPlayer
;
; Raster offsets for objects hidden in the maze
; 0 gun
; 1 cigarette
; 2 cigarette with lipstick
; 3 coiled paper
; 4 footprint
; 5 key
; 6 knife
; 7 crumpled paper
; 8 long rope
; 9 short rope
;
.SASGotClue
 MazeObjectTaken=MazeObject
 MazeObject=0
; show footprint if no maze object
 QueueRasterOffset=4 ; footprint
 if mazeobjecttaken=0 then ShowMazeObject
 QueueRasterOffset=3 ; papers
 if mazeobjecttaken=36 then ShowMazeObject
 QueueRasterOffset=8 ; long rope
 if mazeobjecttaken=longrope then ShowMazeObject
 QueueRasterOffset=9 ; short rope
 if mazeobjecttaken=rope then ShowMazeObject
 QueueRasterOffset=6 ; knife
.ShowMazeObject 
 v1=QueueRasterOffset
 v5=dRemoveRedraw ;  -1 Remove and redraw
 gosub @MCDrawObjectV1 ; display pit
 ObjectNumber=2450 ; draw clue
 goto SASPitAni
;------------
.DoShuffle
 if dx2=0 then @DSNotLR
; going left/right - which way?
 if dx2>50 then DSLeft
; going right - any collision?
 if right=0 then DSRet1
 goto DSLR

.DSLeft
 if left=0 then DSRet1

.DSLR
; shuffle down?
 dx2=0
 if bottom<>0 then DSNotTR
 dx4=65535 ; h:=minus1
.DSRet1
 return

.DSNotTR
; shuffle up?
 if top<>0 then @DSStopPlayer ; blocked in our direction
 dx4=1 ; hspeed
 return
;--
.DSNotLR
; going Up/Down - which way?
 if dx4<50 then DSUp ; h speed: +ve is up
; going down - any collision?
 if bottom=0 then DSRet2
 goto DSUD

.DSUp
 if top=0 then DSRet2

.DSUD
; shuffle left?
 dx4=0 ; hspeed=0
 if left<>0 then DSDownNotBR
 dx2=65535 ;Minus1 ; shuffle left a bit
.DSRet2
 return

.DSDownNotBR
; going down - shuffle right?
 if right<>0 then DSStopPlayer ; blocked in our direction
 dx2=1 ; shuffle right a bit
 return

.DSStopPlayer
; stop movement!
 dx2=0
 dx3=0 ; z speed - unused I think
 dx4=0
 StopPlayerAnimation=1

.DSRet
 return
;-------------
.SpecialSprites
; you can display sprites here, which you don't want
; to put into acbs for some reason.
; They will be displayed in front of EVERYTHING
; except text box

 if Game<>BagGame then BANoBag
 gosub @DisplayLock

.BANoBag
 if Game<>GrappleGame then @SSNoGrapple
; display left strength indicator
 v1=919
 v2=0 ; x
 v3=180 ; z
 v4=v3 ; h:=z-y below
 v5=dPlot
 v6=0 ; no reflection

 x1=ComputerStrength
 asr x1
 asr x1
 asr x1
 add v4,x1 ; left hand strength remaining
 x1=128 ; move down the screen a bit
 sub v4,x1
 gosub @MCDrawObjectV1

 v2=304
 v4=v3
 x1=PlayerStrength
 asr x1 ; divide by 4 to get pixels high
 asr x1
 asr x1
 add v4,x1 ; right hand strength remaining
 x1=128 ; move down the screen a bit
 sub v4,x1
 gosub @MCDrawObjectV1

 v1=923 ; right person hand/arm at bottom
 v2=290
 x1=PlayerForce ; 0..10
 add x1,x1
 x2=x1 ; times 2
 add x1,x1
 add x1,x1 ; times 8
 add x1,x2 ; gives times 10.
 sub v2,x1
 v3=280 ; z
 v4=148 ; h
 gosub @MCDrawObjectV1 ; right force indicator

 v2=65410 ; x
 v1=922 ; left person hand/arm at bottom
 x1=ComputerForce
 add x1,x1
 x2=x1 ; times 2
 add x1,x1
 add x1,x1 ; times 8
 add x1,x2 ; gives times 10
 add v2,x1
 gosub @MCDrawObjectV1 ; Left force indicator

.SSNoGrapple
;
 if game<>BeeGame then SSNoBee
; show number of bees swatted
 x1=MaxBees
 sub x1,BeesSwatted
 v2=0
.ShowBeesSwatted
 if x1>32000 then ShownBeesSwatted
 if x1=0 then ShownBeesSwatted
 v1=968 ; small bee
 v3=0
 v4=0
 v5=dPlot
 v6=0 ; no reflection
 gosub @MCDrawObjectV1
 sub x1,c1 ; loop counter
 add v2,c16 ; next cell position
 if v2<305 then ShowBeesSwatted
.ShownBeesSwatted
;
.SSNoBee
 return
;------
.QueueAnimation0
; queue animation at zero coordinates: ObjectNumber
 QueueObject=ObjectNumber
 return
;-----
.ProcessQueue
 ObjectNumber=QueueObject
 QueueObject=0
 dv2=0; x
 dv3=256 ; z
 dv4=256 ; h
 dv5=dPlot
 dv6=0 ; no reflection
 push RasterOffset
  RasterOffset=QueueRasterOffset
  QueueRasterOffset=0
 gosub @StartFreeACB ;ObjectNumber, dv2, dv3, dv4; returns dx4
 pop RasterOffset
 return
;--------- 
.StartFreeACB0
 dv2=0; x
 dv3=0 ; z
 dv4=0 ; h
 dv5=dPlot
 dv6=0 ; no reflection
 goto @StartFreeACB ;ObjectNumber, dv2..dv4, returns dx4 at coords 0
;----------
.ClearKBD
; only use very occasionally!
 gosub @MCOsrdch
 if v1<>0 then ClearKBD
 return
;---
; Set up MaxScore as the maximum possible score in this 
; particular murder
.CalcMaxScore
 MaxScore=0
 &x1=list4(26) ; evidence message table
 add x1,murder
 add x1,murder ; word based table
 sub x1,c2 ; murder 1 is word entry 0
 &x1=list4(x1) ; x1 points to evidence message table for this murder
 x2=0 ; record of last evidence message, to prevent scoring many 
; times for the same evidence message but with a different 
; intercept message.
.CMSloop
 &x3=list4(x1) ; get intercept message
 if x3=0 then @MakeTheScoreNice ; end of table
 add x1,c2
 &x3=list4(x1) ; get evidence message
 if x3=x2 then CMSsameevidence ; same evidence as previous entry
 x2=x3 ; new evidence message
 add x1,c3
 x4=list4(x1) ; get score / paired flag
 add x1,c1 ; point x1 to next entry / paired list offset
 if x4<>255 then CMSnopair ; no paired message
;
; paired entry - get score of first entry in pair list
 &x5=list4(x1) ; x5 points to pairs table
 add x1,c2 ; point x1 to next entry in main evidence table
 add x5,c3 ; skip pair message and evidence category
 x4=list4(x1) ; get score
;
; remove guilt pointer from score (offset by NPC*10)
.CMSnopair
 gosub @GetGuiltyNpc ; v1=guilty npc, x4=true score value
 if x4>32000 then CSMnegscore ; don't add -ve scores
 add MaxScore,x4 ; add score to tally
.CSMnegscore
 goto @CMSloop ; move on to next entry in evidence table
;
; skip an evidence entry
.CMSsameevidence
 add x1,c3
 x4=list4(x1) ; get score / paired flag
 add x1,c1 ; point x1 to next entry / paired list offset
 if x4<>255 then @CMSloop ; no paired message
 add x1,c2 ; point x1 to next entry in main evidence table
 goto @CMSloop
;---
; We've got the max score in MaxScore, but it's probably 
; some obscure odd number, so round it up to the 
; nearest 10 (100 in the main game). This also caters 
; for any special object scores which are handled in the 
; main acode rather than in the evidence table
.MakeTheScoreNice
 x1=20 ; ~ min possible score
 if MaxScore<x1 then RoundUpMaxScore
 x1=30
 if MaxScore<x1 then RoundUpMaxScore
 x1=40
 if MaxScore<x1 then RoundUpMaxScore
 x1=50
 if MaxScore<x1 then RoundUpMaxScore
 x1=60
 if MaxScore<x1 then RoundUpMaxScore
 x1=70
 if MaxScore<x1 then RoundUpMaxScore
 x1=80
 if MaxScore<x1 then RoundUpMaxScore
 x1=90
 if MaxScore<x1 then RoundUpMaxScore
 x1=100 ; ~ max possible score
.RoundUpMaxScore
 MaxScore=x1
 return
;---
; Number print routine, for debug purposes
;.DebugNumberx1
;push x1
; v1=ArcBigWindowRaster
; TextBoxDisplayed=ArcBigWindowDO
; TextBoxWidth=DefaultTextWidth
; gosub @SetupPrintRaster
;code -
; gosub @iStartPrintToBuffer
;code +
;pop x1
;code -
; print x1
; message cr ; ensure buffer is flushed etc.
; gosub @iEndPrintToBuffer
; gosub @iDisplayBufferedText
;code +
; return
;---
